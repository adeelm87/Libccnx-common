<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>CCNx Common Library: /Users/gscott/Documents/workspace/CCNx_Distillery-Gatekeeper/CCNx_Distillery/src/Libccnx-common/ccnx/common/codec/ccnxCodec_NetworkBuffer.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">CCNx Common Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_16fe5a6cb4619b62438c1360066364fb.html">Libccnx-common</a></li><li class="navelem"><a class="el" href="dir_ca999156402b63f07c663b5e9508e272.html">ccnx</a></li><li class="navelem"><a class="el" href="dir_0ce23f429e33a65a4627580fe4574273.html">common</a></li><li class="navelem"><a class="el" href="dir_d1ed8e9c4e537cf63813a234e25cada0.html">codec</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ccnxCodec_NetworkBuffer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A network buffer represents memory used for network I/O.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A network buffer represents memory used for network I/O. </p>
<p>A network buffer represents memory used for network I/O and may be scatter/gather non-contiguous memory or may be made up for special memory regions, such as DMA memory directly from the kernel.</p>
<p>The general usage pattern of this is to create the network buffer, fill it in with the encoded packet, then create a CCNxCodecNetworkBufferIoVec from it. The IoVec is then used in a gathering write. Calling <a class="el" href="ccnx_codec___network_buffer_8h.html#a2055fba8ca8bc8cb0312b4c8091baeac" title="Creates a read-only CCNxCodecNetworkBufferIoVec representation of the CCNxCodecNetworkBuffer. ">ccnxCodecNetworkBuffer_CreateIoVec()</a> will create a CCNxCodecNetworkBufferIoVec object that has a reference to the original network buffer and will release it when the IoVec is released. A user can get a normal system "struct iovec" from the CCNxCodecNetworkBufferIoVec.</p>
<p>The CCNxCodecNetworkBufferIoVec is a read-only object.</p>
<p>A network buffer uses a <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a> structure for an allocator and de-allocator. The allocator is called to add more memory to the scatter/gather list of memory buffers and the de-allocator is used to return those buffers to the owner. A user could point to "ParcMemoryMemoryBlock" to use the normal parcMemory_allocate() and parcMemory_deallocate() functions. Or, they can use their own or wrap event buffers or wrap kernel memory blocks.</p>
<p>The user can address the memory using a linearized position with <a class="el" href="ccnx_codec___network_buffer_8h.html#a5c735b13a3e16bfa6964901fae73d163" title="Returns the linearlized cursor position in the buffer. ">ccnxCodecNetworkBuffer_Position()</a> and <a class="el" href="ccnx_codec___network_buffer_8h.html#a367eb2ef64bae98b026ab0ff15efc20c" title="Sets the cursor position to the linearized memory location. ">ccnxCodecNetworkBuffer_SetPosition()</a>. If a write would span two (or more) memory blocks, the write function will correctly split the write.</p>
<p>When doing a write that would span two memory blocks, the network buffer may choose to truncate the current block and do an unsplit write to the second block. It will only do this if it would result in a small amount of wasted memory. This can only be done on the first pass through a memory block (if you set the position backwards and do a write that splits over memory blocks, the write must be split).</p>
<p>Add a control to turn off the "optimized" write splitting (i.e. the behavior to truncate the current block and do an unsplit write to the next block).</p>
<p>ccnxCodecNetworkBuffer_ComputeSignature should be factored out of here, like the verifier is factored out</p>
<dl class="section author"><dt>Author</dt><dd>Marc Mosko, Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2013-2015, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/uio.h&gt;</code><br />
<code>#include &lt;parc/algol/parc_Buffer.h&gt;</code><br />
<code>#include &lt;parc/security/parc_Signer.h&gt;</code><br />
</div>
<p><a href="ccnx_codec___network_buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a551be2d5639df9051117fbaabf10f38f"><td class="memItemLeft" align="right" valign="top">CCNxCodecNetworkBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a551be2d5639df9051117fbaabf10f38f">ccnxCodecNetworkBuffer_Create</a> (const <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a> *blockFunctions, void *userarg)</td></tr>
<tr class="memdesc:a551be2d5639df9051117fbaabf10f38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>CCNxCodecNetworkBuffer</code>.  <a href="#a551be2d5639df9051117fbaabf10f38f">More...</a><br /></td></tr>
<tr class="separator:a551be2d5639df9051117fbaabf10f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3195be144aae23981f636f3273c6b1c4"><td class="memItemLeft" align="right" valign="top">CCNxCodecNetworkBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a3195be144aae23981f636f3273c6b1c4">ccnxCodecNetworkBuffer_CreateFromArray</a> (const <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a> *blockFunctions, void *userarg, size_t length, uint8_t memory[length])</td></tr>
<tr class="memdesc:a3195be144aae23981f636f3273c6b1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>CCNxCodecNetworkBuffer</code> from a buffer block.  <a href="#a3195be144aae23981f636f3273c6b1c4">More...</a><br /></td></tr>
<tr class="separator:a3195be144aae23981f636f3273c6b1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3590eae94fec72c04dbebcfeb3b724"><td class="memItemLeft" align="right" valign="top">CCNxCodecNetworkBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a7a3590eae94fec72c04dbebcfeb3b724">ccnxCodecNetworkBuffer_Acquire</a> (CCNxCodecNetworkBuffer *original)</td></tr>
<tr class="memdesc:a7a3590eae94fec72c04dbebcfeb3b724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of references to a <code>CCNxCodecNetworkBuffer</code>.  <a href="#a7a3590eae94fec72c04dbebcfeb3b724">More...</a><br /></td></tr>
<tr class="separator:a7a3590eae94fec72c04dbebcfeb3b724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a29ddf702ce251a9c3ae7194314888a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a1a29ddf702ce251a9c3ae7194314888a">ccnxCodecNetworkBuffer_Release</a> (CCNxCodecNetworkBuffer **bufferPtr)</td></tr>
<tr class="memdesc:a1a29ddf702ce251a9c3ae7194314888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired reference to the specified instance, decrementing the reference count for the instance.  <a href="#a1a29ddf702ce251a9c3ae7194314888a">More...</a><br /></td></tr>
<tr class="separator:a1a29ddf702ce251a9c3ae7194314888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c735b13a3e16bfa6964901fae73d163"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a5c735b13a3e16bfa6964901fae73d163">ccnxCodecNetworkBuffer_Position</a> (const CCNxCodecNetworkBuffer *buffer)</td></tr>
<tr class="memdesc:a5c735b13a3e16bfa6964901fae73d163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the linearlized cursor position in the buffer.  <a href="#a5c735b13a3e16bfa6964901fae73d163">More...</a><br /></td></tr>
<tr class="separator:a5c735b13a3e16bfa6964901fae73d163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3d49b653f2180615f53fb3a72e02ca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#aad3d49b653f2180615f53fb3a72e02ca">ccnxCodecNetworkBuffer_Limit</a> (const CCNxCodecNetworkBuffer *buffer)</td></tr>
<tr class="memdesc:aad3d49b653f2180615f53fb3a72e02ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum position to which is written.  <a href="#aad3d49b653f2180615f53fb3a72e02ca">More...</a><br /></td></tr>
<tr class="separator:aad3d49b653f2180615f53fb3a72e02ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367eb2ef64bae98b026ab0ff15efc20c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a367eb2ef64bae98b026ab0ff15efc20c">ccnxCodecNetworkBuffer_SetPosition</a> (CCNxCodecNetworkBuffer *buffer, size_t position)</td></tr>
<tr class="memdesc:a367eb2ef64bae98b026ab0ff15efc20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cursor position to the linearized memory location.  <a href="#a367eb2ef64bae98b026ab0ff15efc20c">More...</a><br /></td></tr>
<tr class="separator:a367eb2ef64bae98b026ab0ff15efc20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d207b0d08bbab7fa4ea0e2de97bc357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a4d207b0d08bbab7fa4ea0e2de97bc357">ccnxCodecNetworkBuffer_Finalize</a> (CCNxCodecNetworkBuffer *buffer)</td></tr>
<tr class="memdesc:a4d207b0d08bbab7fa4ea0e2de97bc357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the buffer limit to the current position.  <a href="#a4d207b0d08bbab7fa4ea0e2de97bc357">More...</a><br /></td></tr>
<tr class="separator:a4d207b0d08bbab7fa4ea0e2de97bc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ffbeb30c133c91da3fcbe7f109ee5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a40ffbeb30c133c91da3fcbe7f109ee5c">ccnxCodecNetworkBuffer_PutUint8</a> (CCNxCodecNetworkBuffer *buffer, uint8_t value)</td></tr>
<tr class="memdesc:a40ffbeb30c133c91da3fcbe7f109ee5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>uint8_t</code> to the current cursor position, allocating as necessary.  <a href="#a40ffbeb30c133c91da3fcbe7f109ee5c">More...</a><br /></td></tr>
<tr class="separator:a40ffbeb30c133c91da3fcbe7f109ee5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bb665e706d97bedeed2b8f3ef65619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a91bb665e706d97bedeed2b8f3ef65619">ccnxCodecNetworkBuffer_PutUint16</a> (CCNxCodecNetworkBuffer *buffer, uint16_t value)</td></tr>
<tr class="memdesc:a91bb665e706d97bedeed2b8f3ef65619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>uint16_t</code> to the current cursor position, allocating as necessary.  <a href="#a91bb665e706d97bedeed2b8f3ef65619">More...</a><br /></td></tr>
<tr class="separator:a91bb665e706d97bedeed2b8f3ef65619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0573459f6f233e05c96bbb6cabad102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#ad0573459f6f233e05c96bbb6cabad102">ccnxCodecNetworkBuffer_PutUint32</a> (CCNxCodecNetworkBuffer *buffer, uint32_t value)</td></tr>
<tr class="memdesc:ad0573459f6f233e05c96bbb6cabad102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>uint32_t</code> to the current cursor position, allocating as necessary.  <a href="#ad0573459f6f233e05c96bbb6cabad102">More...</a><br /></td></tr>
<tr class="separator:ad0573459f6f233e05c96bbb6cabad102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca799a011152fb9681454fced6d2a6f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#aca799a011152fb9681454fced6d2a6f1">ccnxCodecNetworkBuffer_PutUint64</a> (CCNxCodecNetworkBuffer *buffer, uint64_t value)</td></tr>
<tr class="memdesc:aca799a011152fb9681454fced6d2a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>uint64_t</code> to the current cursor position, allocating as necessary.  <a href="#aca799a011152fb9681454fced6d2a6f1">More...</a><br /></td></tr>
<tr class="separator:aca799a011152fb9681454fced6d2a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a2b52774de783b922cd31e472e055c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#ac3a2b52774de783b922cd31e472e055c">ccnxCodecNetworkBuffer_PutArray</a> (CCNxCodecNetworkBuffer *buffer, size_t length, const uint8_t array[length])</td></tr>
<tr class="memdesc:ac3a2b52774de783b922cd31e472e055c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array to the current cursor position, allocating as necessary.  <a href="#ac3a2b52774de783b922cd31e472e055c">More...</a><br /></td></tr>
<tr class="separator:ac3a2b52774de783b922cd31e472e055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f2d2e50b27feabaeaf1230f26401a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a35f2d2e50b27feabaeaf1230f26401a4">ccnxCodecNetworkBuffer_PutBuffer</a> (CCNxCodecNetworkBuffer *buffer, PARCBuffer *value)</td></tr>
<tr class="memdesc:a35f2d2e50b27feabaeaf1230f26401a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the current cursor position, allocating as necessary.  <a href="#a35f2d2e50b27feabaeaf1230f26401a4">More...</a><br /></td></tr>
<tr class="separator:a35f2d2e50b27feabaeaf1230f26401a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff69dd833d863cfe3533139d4f200979"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#aff69dd833d863cfe3533139d4f200979">ccnxCodecNetworkBuffer_CreateParcBuffer</a> (CCNxCodecNetworkBuffer *buffer)</td></tr>
<tr class="memdesc:aff69dd833d863cfe3533139d4f200979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linearized memory buffer.  <a href="#aff69dd833d863cfe3533139d4f200979">More...</a><br /></td></tr>
<tr class="separator:aff69dd833d863cfe3533139d4f200979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42af475573c6de38da90257e8ecb4961"><td class="memItemLeft" align="right" valign="top">PARCSignature *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a42af475573c6de38da90257e8ecb4961">ccnxCodecNetworkBuffer_ComputeSignature</a> (CCNxCodecNetworkBuffer *buffer, size_t start, size_t end, PARCSigner *signer)</td></tr>
<tr class="memdesc:a42af475573c6de38da90257e8ecb4961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a signer over the network buffer.  <a href="#a42af475573c6de38da90257e8ecb4961">More...</a><br /></td></tr>
<tr class="separator:a42af475573c6de38da90257e8ecb4961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ce4d419b161f73fc49372770ef0964"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a20ce4d419b161f73fc49372770ef0964">ccnxCodecNetworkBuffer_GetUint8</a> (const CCNxCodecNetworkBuffer *netbuff, size_t position)</td></tr>
<tr class="memdesc:a20ce4d419b161f73fc49372770ef0964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>uint8_t</code> byte from the buffer, does not change position.  <a href="#a20ce4d419b161f73fc49372770ef0964">More...</a><br /></td></tr>
<tr class="separator:a20ce4d419b161f73fc49372770ef0964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e34fb89f7d2541952382278e5af54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a841e34fb89f7d2541952382278e5af54">ccnxCodecNetworkBuffer_Display</a> (const CCNxCodecNetworkBuffer *netbuff, unsigned indent)</td></tr>
<tr class="memdesc:a841e34fb89f7d2541952382278e5af54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the buffer to the console.  <a href="#a841e34fb89f7d2541952382278e5af54">More...</a><br /></td></tr>
<tr class="separator:a841e34fb89f7d2541952382278e5af54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2055fba8ca8bc8cb0312b4c8091baeac"><td class="memItemLeft" align="right" valign="top">CCNxCodecNetworkBufferIoVec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a2055fba8ca8bc8cb0312b4c8091baeac">ccnxCodecNetworkBuffer_CreateIoVec</a> (CCNxCodecNetworkBuffer *buffer)</td></tr>
<tr class="memdesc:a2055fba8ca8bc8cb0312b4c8091baeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a read-only <code>CCNxCodecNetworkBufferIoVec</code> representation of the <code>CCNxCodecNetworkBuffer</code>.  <a href="#a2055fba8ca8bc8cb0312b4c8091baeac">More...</a><br /></td></tr>
<tr class="separator:a2055fba8ca8bc8cb0312b4c8091baeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b5f9421291fc7d3ef7982871b9437"><td class="memItemLeft" align="right" valign="top">CCNxCodecNetworkBufferIoVec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a351b5f9421291fc7d3ef7982871b9437">ccnxCodecNetworkBufferIoVec_Acquire</a> (CCNxCodecNetworkBufferIoVec *vec)</td></tr>
<tr class="memdesc:a351b5f9421291fc7d3ef7982871b9437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of references to a <code>CCNxCodecNetworkBufferIoVec</code>.  <a href="#a351b5f9421291fc7d3ef7982871b9437">More...</a><br /></td></tr>
<tr class="separator:a351b5f9421291fc7d3ef7982871b9437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d1759348e8fe09c694cce67805ac05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a62d1759348e8fe09c694cce67805ac05">ccnxCodecNetworkBufferIoVec_Release</a> (CCNxCodecNetworkBufferIoVec **vecPtr)</td></tr>
<tr class="memdesc:a62d1759348e8fe09c694cce67805ac05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired reference to the specified instance, decrementing the reference count for the instance.  <a href="#a62d1759348e8fe09c694cce67805ac05">More...</a><br /></td></tr>
<tr class="separator:a62d1759348e8fe09c694cce67805ac05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146e54613fea1b3fdcee4d1deeb0ad01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a146e54613fea1b3fdcee4d1deeb0ad01">ccnxCodecNetworkBufferIoVec_GetCount</a> (CCNxCodecNetworkBufferIoVec *vec)</td></tr>
<tr class="memdesc:a146e54613fea1b3fdcee4d1deeb0ad01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of extents in the iovec.  <a href="#a146e54613fea1b3fdcee4d1deeb0ad01">More...</a><br /></td></tr>
<tr class="separator:a146e54613fea1b3fdcee4d1deeb0ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cf34dc1a347cf14ae9f581c3365b8"><td class="memItemLeft" align="right" valign="top">const struct iovec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a935cf34dc1a347cf14ae9f581c3365b8">ccnxCodecNetworkBufferIoVec_GetArray</a> (CCNxCodecNetworkBufferIoVec *vec)</td></tr>
<tr class="memdesc:a935cf34dc1a347cf14ae9f581c3365b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iovec representation of the memory.  <a href="#a935cf34dc1a347cf14ae9f581c3365b8">More...</a><br /></td></tr>
<tr class="separator:a935cf34dc1a347cf14ae9f581c3365b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccc75462a9baa5832606a6e9be852f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a8ccc75462a9baa5832606a6e9be852f5">ccnxCodecNetworkBufferIoVec_Display</a> (const CCNxCodecNetworkBufferIoVec *vec, int indent)</td></tr>
<tr class="memdesc:a8ccc75462a9baa5832606a6e9be852f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispalys the CCNxCodecNetworkBufferIoVec to the console.  <a href="#a8ccc75462a9baa5832606a6e9be852f5">More...</a><br /></td></tr>
<tr class="separator:a8ccc75462a9baa5832606a6e9be852f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a065badab0c5101571eca7278bfefe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a02a065badab0c5101571eca7278bfefe">ccnxCodecNetworkBufferIoVec_Length</a> (const CCNxCodecNetworkBufferIoVec *vec)</td></tr>
<tr class="memdesc:a02a065badab0c5101571eca7278bfefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total bytes of all iovecs.  <a href="#a02a065badab0c5101571eca7278bfefe">More...</a><br /></td></tr>
<tr class="separator:a02a065badab0c5101571eca7278bfefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbf982caaa8b3b9305ac613117abc9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___network_buffer_8h.html#a2dbf982caaa8b3b9305ac613117abc9a">ccnxCodecNetworkBufferIoVec_Equals</a> (const CCNxCodecNetworkBufferIoVec *a, const CCNxCodecNetworkBufferIoVec *b)</td></tr>
<tr class="memdesc:a2dbf982caaa8b3b9305ac613117abc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <code>CCNxCodecNetworkBufferIoVec</code> instances are equal.  <a href="#a2dbf982caaa8b3b9305ac613117abc9a">More...</a><br /></td></tr>
<tr class="separator:a2dbf982caaa8b3b9305ac613117abc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6a92b8dd93bf32335da2ad0461e3b21b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a92b8dd93bf32335da2ad0461e3b21b"></a>
const <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ParcMemoryMemoryBlock</b></td></tr>
<tr class="separator:a6a92b8dd93bf32335da2ad0461e3b21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7a3590eae94fec72c04dbebcfeb3b724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecNetworkBuffer* ccnxCodecNetworkBuffer_Acquire </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of references to a <code>CCNxCodecNetworkBuffer</code>. </p>
<p>Note that new <code>CCNxCodecNetworkBuffer</code> is not created, only that the given <code>CCNxCodecNetworkBuffer</code> reference count is incremented. Discard the reference by invoking <code>ccnxCodecNetworkBuffer_Release</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>A pointer to a <code>CCNxCodecNetworkBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input <code>CCNxCodecNetworkBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    CCNxCodecNetworkBuffer *handle = ccnxCodecNetworkBuffer_Acquire(netbuff);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ...</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;handle);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a42af475573c6de38da90257e8ecb4961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCSignature* ccnxCodecNetworkBuffer_ComputeSignature </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCSigner *&#160;</td>
          <td class="paramname"><em>signer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a signer over the network buffer. </p>
<p>Runs a <a class="el" href="">PARCSigner</a> over a specified range of the network buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start position (must be 0 &lt;= start &lt; Limit) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The last posiiton (start &lt; end &lt;= Limit) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signer</td><td>The <code>PARCSigner</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null The <a class="el" href="">PARCSignature</a> computed by the signer </dd>
<dd>
null An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcSecurity_Init();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCSigner *signer = parcSigner_Create(parcPublicKeySignerPkcs12Store_Open(&quot;test_rsa.p12&quot;, &quot;blueberry&quot;, PARCCryptoHashType_SHA256));</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint8_t);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxCodecNetworkBuffer_PutUint8(netbuff, 0x12);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    PARCSignature *sig = ccnxCodecNetworkBuffer_ComputeSignature(netbuff, 0, ccnxCodecNetworkBuffer_Limit(netbuff), signer);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a551be2d5639df9051117fbaabf10f38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecNetworkBuffer* ccnxCodecNetworkBuffer_Create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a> *&#160;</td>
          <td class="paramname"><em>blockFunctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>CCNxCodecNetworkBuffer</code>. </p>
<p>The first memory block is allocated using the default settings. The parameter "userarg" will be passed to the <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a> for allocations and de-allocations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockFunctions</td><td>The allocator/de-allocator to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userarg</td><td>Passed to all calls to the blockFunctions, may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null An allocated memory block using memory from blockFunctions. </dd>
<dd>
null An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer * netbuffer = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3195be144aae23981f636f3273c6b1c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecNetworkBuffer* ccnxCodecNetworkBuffer_CreateFromArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a> *&#160;</td>
          <td class="paramname"><em>blockFunctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userarg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memory</em>[length]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code>CCNxCodecNetworkBuffer</code> from a buffer block. </p>
<p>The first memory block of the Network Buffer will wrap the user provided memory.</p>
<p>If the allocator is non-null then the user could append more memory blocks.</p>
<p>The deallocator in the blockFunctions will be called on the memory when done. The userarg will be passed to the <a class="el" href="struct_c_c_nx_codec_network_buffer_memory_block_functions.html">CCNxCodecNetworkBufferMemoryBlockFunctions</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockFunctions</td><td>The allocator/de-allocator to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userarg</td><td>Passed to all calls to the blockFunctions, may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the user-provided memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memory</td><td>The user-provided memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null An allocated memory block that wraps the user-provided memory. </dd>
<dd>
null An error occurred.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2055fba8ca8bc8cb0312b4c8091baeac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecNetworkBufferIoVec* ccnxCodecNetworkBuffer_CreateIoVec </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a read-only <code>CCNxCodecNetworkBufferIoVec</code> representation of the <code>CCNxCodecNetworkBuffer</code>. </p>
<p>Creates a reference to the <code>CCNxCodecNetworkBuffer</code>, so the buffer will not go away until the IoVec is released. It is a zero-copy operation. The IoVec is a read-only representation. It is used to return a "struct iovec" for doing a gathering write.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code> (will acquire a reference to it).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null An allocated <a class="el" href="">CCNxCodecNetworkBufferIoVec</a>, you must call <a class="el" href="ccnx_codec___network_buffer_8h.html#a62d1759348e8fe09c694cce67805ac05">ccnxCodecNetworkBufferIoVec_Release</a> </dd>
<dd>
null An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // the memory represented by iov will be &quot;interest_nameA&quot;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    const struct iovec * iov = ccnxCodecNetworkBufferIoVec_GetArray(vec);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // final release of &quot;netbuff&quot; too</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aff69dd833d863cfe3533139d4f200979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* ccnxCodecNetworkBuffer_CreateParcBuffer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a linearized memory buffer. </p>
<p>Allocates a single buffer and copies the <code>CCNxCodecNetworkBuffer</code> to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null A copy of the network buffer's written contents. </dd>
<dd>
null An error.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint8_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint8(netbuff, 0x12);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    PARCBuffer *buffer = ccnxCodecNetworkBuffer_CreateParcBuffer(netbuff);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a841e34fb89f7d2541952382278e5af54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_Display </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>netbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the buffer to the console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netbuff</td><td>A <code>CCNxCodecNetworkBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>The number of spaces by which to indent the output.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint8_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint8(netbuff, 0x12);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxCodecNetworkBuffer_Display(netbuff, 0);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4d207b0d08bbab7fa4ea0e2de97bc357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_Finalize </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the buffer limit to the current position. </p>
<p>Throws away anything after.</p>
<p>The Limit will be set to the current position. Any bytes left after the new Limit are discarded and un-recoverable. This should be done after finishing writing to the buffer, especially if the buffer was backed up to discard or overwrite previous data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint16_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint16(netbuff, 0x1234);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxCodecNetworkBuffer_SetPosition(netbuff, 1);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxCodecNetworkBuffer_Finalize(netbuff);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // the buffer is now only &#39;0x12&#39; and the limit is reduced to 1.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a20ce4d419b161f73fc49372770ef0964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccnxCodecNetworkBuffer_GetUint8 </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>netbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <code>uint8_t</code> byte from the buffer, does not change position. </p>
<p>Reads the byte at the given position. The position must be less than the buffer's limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netbuff</td><td>An allocated memory buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Must be 0 &lt;= position &lt; Limit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number The specified byte</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint8_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint8(netbuff, 0x12);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    uint8_t byte = ccnxCodecNetworkBuffer_GetUint8(netbuff, 0);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aad3d49b653f2180615f53fb3a72e02ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccnxCodecNetworkBuffer_Limit </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum position to which is written. </p>
<p>The maximum position of the currently written memory, as if it were linear memory. The limit will be "0" if no data has been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>An allocated network buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lineaized capacity (bytes).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t limit = ccnxCodecNetworkBuffer_Limit(netbuff);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // limit is msg_length since the buffer was created as a wrapper for the packet_buffer</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5c735b13a3e16bfa6964901fae73d163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccnxCodecNetworkBuffer_Position </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the linearlized cursor position in the buffer. </p>
<p>Returns the current cursor position in linearized memory location (this does not actually linearize the memory).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>An allocated network buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linearized memory position (bytes).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t position = ccnxCodecNetworkBuffer_Position(netbuff);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // position is 0 since nothing has been written yet</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac3a2b52774de783b922cd31e472e055c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_PutArray </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>array</em>[length]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array to the current cursor position, allocating as necessary. </p>
<p>Writes to the current cursor position. If the cursor is at the end of a memory block, a new memory block will be allocated. Will assert if cannot allocate more memory (or if the allocator is null). The value is written in array order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>AThe length of the array to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint8_t array[5] = {1,2,3,4,5};</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + 5;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, array, 5);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    size_t position = ccnxCodecNetworkBuffer_Position(netbuff);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    // position will equal newPosition</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a35f2d2e50b27feabaeaf1230f26401a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_PutBuffer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to the current cursor position, allocating as necessary. </p>
<p>Writes to the current cursor position. If the cursor is at the end of a memory block, a new memory block will be allocated. Will assert if cannot allocate more memory (or if the allocator is null). The value is written in buffer order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint8_t array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    PARCBuffer *buffer = parcBuffer_Wrap(array, 10, 0, 10);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + 10;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxCodecNetworkBuffer_PutBuffer(netbuff, buffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    size_t position = ccnxCodecNetworkBuffer_Position(netbuff);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    // position will equal newPosition</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a91bb665e706d97bedeed2b8f3ef65619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_PutUint16 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>uint16_t</code> to the current cursor position, allocating as necessary. </p>
<p>Writes to the current cursor position. If the cursor is at the end of a memory block, a new memory block will be allocated. Will assert if cannot allocate more memory (or if the allocator is null). The value is written in network byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint16_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint16(netbuff, 0x1234);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    size_t position = ccnxCodecNetworkBuffer_Position(netbuff);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // position will equal newPosition</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad0573459f6f233e05c96bbb6cabad102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_PutUint32 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>uint32_t</code> to the current cursor position, allocating as necessary. </p>
<p>Writes to the current cursor position. If the cursor is at the end of a memory block, a new memory block will be allocated. Will assert if cannot allocate more memory (or if the allocator is null). The value is written in network byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint32_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint32(netbuff, 0x12345678);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    size_t position = ccnxCodecNetworkBuffer_Position(netbuff);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // position will equal newPosition</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aca799a011152fb9681454fced6d2a6f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_PutUint64 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>uint64_t</code> to the current cursor position, allocating as necessary. </p>
<p>Writes to the current cursor position. If the cursor is at the end of a memory block, a new memory block will be allocated. Will assert if cannot allocate more memory (or if the allocator is null). The value is written in network byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint64_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint64(netbuff, 0x1234567812345678);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    size_t position = ccnxCodecNetworkBuffer_Position(netbuff);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // position will equal newPosition</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a40ffbeb30c133c91da3fcbe7f109ee5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_PutUint8 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>uint8_t</code> to the current cursor position, allocating as necessary. </p>
<p>Writes to the current cursor position. If the cursor is at the end of a memory block, a new memory block will be allocated. Will assert if cannot allocate more memory (or if the allocator is null).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t newPosition = ccnxCodecNetworkBuffer_Position(netbuff) + sizeof(uint8_t);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxCodecNetworkBuffer_PutUint8(netbuff, 0x12);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    size_t position = ccnxCodecNetworkBuffer_Position(netbuff);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // position will equal newPosition</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1a29ddf702ce251a9c3ae7194314888a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_Release </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer **&#160;</td>
          <td class="paramname"><em>bufferPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously acquired reference to the specified instance, decrementing the reference count for the instance. </p>
<p>The pointer to the instance is set to NULL as a side-effect of this function.</p>
<p>If the invocation causes the last reference to the instance to be released, the instance is deallocated and the instance's implementation will perform additional cleanup and release other privately held references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufferPtr</td><td>A pointer to a pointer to the instance to release.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    CCNxCodecNetworkBuffer *handle = ccnxCodecNetworkBuffer_Acquire(netbuff);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ...</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;handle);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a367eb2ef64bae98b026ab0ff15efc20c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBuffer_SetPosition </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cursor position to the linearized memory location. </p>
<p>Sets the cursor to the linearized memory location. It must not exceed <a class="el" href="ccnx_codec___network_buffer_8h.html#aad3d49b653f2180615f53fb3a72e02ca">ccnxCodecNetworkBuffer_Limit</a>().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>An allocated <code>CCNxCodecNetworkBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The linearized buffer position.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t *packet_buffer;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    packet_buffer = parcMemory_Allocate(msg_length);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    read(fd, packet_buffer, msg_length);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_CreateFromArray(&amp;ParcMemoryMemoryBlock, NULL, msg_length, packet_buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxCodecNetworkBuffer_SetPosition(netbuff, 1);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // the position is now 1, instead of 0</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a351b5f9421291fc7d3ef7982871b9437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecNetworkBufferIoVec* ccnxCodecNetworkBufferIoVec_Acquire </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBufferIoVec *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of references to a <code>CCNxCodecNetworkBufferIoVec</code>. </p>
<p>Note that new <code>CCNxCodecNetworkBufferIoVec</code> is not created, only that the given <code>CCNxCodecNetworkBufferIoVec</code> reference count is incremented. Discard the reference by invoking <code>ccnxCodecNetworkBufferIoVec_Release</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>A pointer to a <code>CCNxCodecNetworkBufferIoVec</code> instance to acquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>vec</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    CCNxCodecNetworkBufferIoVec *handle = ccnxCodecNetworkBufferIoVec_Acquire(vec);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    const struct iovec *iov = ccnxCodecNetworkBufferIoVec_GetArray(handle);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;handle);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8ccc75462a9baa5832606a6e9be852f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBufferIoVec_Display </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecNetworkBufferIoVec *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispalys the CCNxCodecNetworkBufferIoVec to the console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>A <code>CCNxCodecNetworkBufferIoVec</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>The number of spaces by which to indent the output.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxCodecNetworkBufferIoVec_Display(vec, 0);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2dbf982caaa8b3b9305ac613117abc9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecNetworkBufferIoVec_Equals </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecNetworkBufferIoVec *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CCNxCodecNetworkBufferIoVec *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <code>CCNxCodecNetworkBufferIoVec</code> instances are equal. </p>
<p>The following equivalence relations on non-null <code>CCNxCodecNetworkBufferIoVec</code> instances are maintained:</p>
<ul>
<li>It is reflexive: for any non-null reference value x, <code>ccnxCodecNetworkBufferIoVec_Equals(x, x)</code> must return true.</li>
<li>It is symmetric: for any non-null reference values x and y, <code>ccnxCodecNetworkBufferIoVec_Equals(x, y)</code> must return true if and only if <code>ccnxCodecNetworkBufferIoVec_Equals(y x)</code> returns true.</li>
<li>It is transitive: for any non-null reference values x, y, and z, if <code>ccnxCodecNetworkBufferIoVec_Equals(x, y)</code> returns true and <code>ccnxCodecNetworkBufferIoVec_Equals(y, z)</code> returns true, then <code>ccnxCodecNetworkBufferIoVec_Equals(x, z)</code> must return true.</li>
<li>It is consistent: for any non-null reference values x and y, multiple invocations of <code>ccnxCodecNetworkBufferIoVec_Equals(x, y)</code> consistently return true or consistently return false.</li>
<li>For any non-null reference value x, <code>ccnxCodecNetworkBufferIoVec_Equals(x, NULL)</code> must return false.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A pointer to a <code>CCNxCodecNetworkBufferIoVec</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A pointer to a <code>CCNxCodecNetworkBufferIoVec</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>CCNxCodecNetworkBufferIoVec</code> x and y are equal. </dd>
<dd>
false if <code>CCNxCodecNetworkBufferIoVec</code> x and y are not equal.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec1 = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxCodecNetworkBufferIoVec *vec2 = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    if (ccnxCodecNetworkBufferIoVec_Equals(vec1, vec2)) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        printf(&quot;IOVectors are equal.\n&quot;);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    } else {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;         printf(&quot;IOVectors are NOT equal.\n&quot;);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;     }</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a935cf34dc1a347cf14ae9f581c3365b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct iovec* ccnxCodecNetworkBufferIoVec_GetArray </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBufferIoVec *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iovec representation of the memory. </p>
<p>Returns the internal iovec representation of the memory. You do NOT need to free this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>An allocated <code>CCNxCodecNetworkBufferIoVec</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null The internal iovec representation of the memory, do not free </dd>
<dd>
null An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // the memory represented by iov will be &quot;interest_nameA&quot;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    writev(fh, ccnxCodecNetworkBufferIoVec_GetArray(vec), ccnxCodecNetworkBufferIoVec_GetCount(vec));</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // final release of &quot;netbuff&quot; too</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a146e54613fea1b3fdcee4d1deeb0ad01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccnxCodecNetworkBufferIoVec_GetCount </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBufferIoVec *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of extents in the iovec. </p>
<p>The number of memory buffers gathered in the iovec.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>An allocated <code>CCNxCodecNetworkBufferIoVec</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of buffers gathered in the iovec.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // the memory represented by iov will be &quot;interest_nameA&quot;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    writev(fh, ccnxCodecNetworkBufferIoVec_GetArray(vec), ccnxCodecNetworkBufferIoVec_GetCount(vec));</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // final release of &quot;netbuff&quot; too</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a02a065badab0c5101571eca7278bfefe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccnxCodecNetworkBufferIoVec_Length </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecNetworkBufferIoVec *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total bytes of all iovecs. </p>
<p>The total number of bytes as if linearized memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>An allocated <code>CCNxCodecNetworkBufferIoVec</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number The total bytes represented by all iovecs</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t interestSize = ccnxCodecNetworkBufferIoVec_Length(vec);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // interestSize will be the size of the linearized interest put into the network buffer</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a62d1759348e8fe09c694cce67805ac05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecNetworkBufferIoVec_Release </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecNetworkBufferIoVec **&#160;</td>
          <td class="paramname"><em>vecPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously acquired reference to the specified instance, decrementing the reference count for the instance. </p>
<p>The pointer to the instance is set to NULL as a side-effect of this function.</p>
<p>If the invocation causes the last reference to the instance to be released, the instance is deallocated and the instance's implementation will perform additional cleanup and release other privately held references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vecPtr</td><td>A pointer to a pointer to the instance to release.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxCodecNetworkBuffer *netbuff = ccnxCodecNetworkBuffer_Create(&amp;ParcMemoryMemoryBlock, NULL);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ccnxCodecNetworkBuffer_PutArray(netbuff, sizeof(interest_nameA), interest_nameA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxCodecNetworkBufferIoVec *vec = ccnxCodecNetworkBuffer_CreateIoVec(netbuff);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxCodecNetworkBuffer_Release(&amp;netbuff);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    const struct iovec *iov = ccnxCodecNetworkBufferIoVec_GetArray(vec);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxCodecNetworkBufferIoVec_Release(&amp;vec);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright  2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Mon Aug 29 2016 12:44:52
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084575; 
var sc_invisible=0;
var sc_security="bed914f8"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" src="http://c.statcounter.com/11084575/0/bed914f8/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>CCNx Common Library: /Users/gscott/Documents/workspace/CCNx_Distillery-Gatekeeper/CCNx_Distillery/src/Libccnx-common/ccnx/common/codec/ccnxCodec_TlvDecoder.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">CCNx Common Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_16fe5a6cb4619b62438c1360066364fb.html">Libccnx-common</a></li><li class="navelem"><a class="el" href="dir_ca999156402b63f07c663b5e9508e272.html">ccnx</a></li><li class="navelem"><a class="el" href="dir_0ce23f429e33a65a4627580fe4574273.html">common</a></li><li class="navelem"><a class="el" href="dir_d1ed8e9c4e537cf63813a234e25cada0.html">codec</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ccnxCodec_TlvDecoder.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>TLV codec for messages.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TLV codec for messages. </p>
<p>TLV decoder</p>
<p>Terminology: type = a field that labels a value length = the byte lenth of the value value = the data header = type + length container= a value that contains TLVs</p>
<p>For example, in this structure, the "type 1" TLV is a container that holds a second TLV The second TLV is a terminal, and holds an opaque value.</p>
<p>{ .type = 1, .length = 20, .value = { .type = 2, .length = 16, .value ="It was a dark a " } }</p>
<p>To decode the above example, we would use the decoder like this:</p>
<div class="fragment"><div class="line">{</div><div class="line">     CCNxCodecTlvDecoder *decoder = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a72997719140167a7b42447834ce0e1ba">ccnxCodecTlvDecoder_Create</a>(container);</div><div class="line">     <span class="keywordtype">unsigned</span> type   = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a26b9e6cfcf2f50db0805689b9e538bdc">ccnxCodecTlvDecoder_GetType</a>(decoder);</div><div class="line">     <span class="keywordtype">unsigned</span> length = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a7462962a9d507de768607080c68bdc33">ccnxCodecTlvDecoder_GetLength</a>(decoder);</div><div class="line">     <span class="keywordflow">if</span> (type == 3) {</div><div class="line">         <span class="keywordtype">size_t</span> end = ccnxCodecTlvDecoder_GetPosition(decoder) + length;</div><div class="line">         <span class="keywordflow">while</span> ( ccnxCodecTlvDecoder_GetPosition(decoder) &lt; end ) {</div><div class="line">             type = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a26b9e6cfcf2f50db0805689b9e538bdc">ccnxCodecTlvDecoder_GetType</a>(decoder);</div><div class="line">             length = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a7462962a9d507de768607080c68bdc33">ccnxCodecTlvDecoder_GetLength</a>(decoder);</div><div class="line">             <span class="keywordflow">if</span> (type == 1) {</div><div class="line">                 PARCBuffer *name = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">                 <span class="comment">// use name, then release it</span></div><div class="line">             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == 2) {</div><div class="line">                 PARCBuffer *address = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">                 <span class="comment">// use address, then release it</span></div><div class="line">             }</div><div class="line">         }</div><div class="line">     }</div><div class="line">     PARCReadOnlyBuffer * value = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">}</div></div><!-- fragment --><p>Another way to do the same parsing without having to use `ccnxCodecTlvDecoder_GetPosition' is to recursively parse each value:</p>
<div class="fragment"><div class="line">{</div><div class="line">     CCNxCodecTlvDecoder *decoder = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a72997719140167a7b42447834ce0e1ba">ccnxCodecTlvDecoder_Create</a>(container);</div><div class="line">     <span class="keywordtype">unsigned</span> type   = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a26b9e6cfcf2f50db0805689b9e538bdc">ccnxCodecTlvDecoder_GetType</a>(decoder);</div><div class="line">     <span class="keywordtype">unsigned</span> length = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a7462962a9d507de768607080c68bdc33">ccnxCodecTlvDecoder_GetLength</a>(decoder);</div><div class="line">     PARCBuffer * value = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">     <span class="keywordflow">if</span> (type == 3) {</div><div class="line">         CCNxCodecTlvDecoder *innerDecoder = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a72997719140167a7b42447834ce0e1ba">ccnxCodecTlvDecoder_Create</a>(value);</div><div class="line">         <span class="keywordflow">while</span> ( ! <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae72c49e1956ea30390d7c7ee69620bfb">ccnxCodecTlvDecoder_IsEmpty</a>(innerDecoder) ) {</div><div class="line">             type = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a26b9e6cfcf2f50db0805689b9e538bdc">ccnxCodecTlvDecoder_GetType</a>(decoder);</div><div class="line">             length = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a7462962a9d507de768607080c68bdc33">ccnxCodecTlvDecoder_GetLength</a>(decoder);</div><div class="line">             <span class="keywordflow">if</span> (type == 1) {</div><div class="line">                 PARCBuffer *name = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">                 <span class="comment">// use name, then release it</span></div><div class="line">             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == 2) {</div><div class="line">                 PARCBuffer *address = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">                 <span class="comment">// use address, then release it</span></div><div class="line">             }</div><div class="line">         }</div><div class="line">         <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a974cebf8dcf1db78407db5a4804bcb76">ccnxCodecTlvDecoder_Destroy</a>(&amp;innerDecoder);</div><div class="line">     }</div><div class="line">     PARCReadOnlyBuffer * value = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">}</div></div><!-- fragment --><p>And an even cleaner way is to use ccnxCodecTlvDecoder_GetContainer to pull out sub-decoders</p>
<div class="fragment"><div class="line">{</div><div class="line">     CCNxCodecTlvDecoder *decoder = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a72997719140167a7b42447834ce0e1ba">ccnxCodecTlvDecoder_Create</a>(container);</div><div class="line">     <span class="keywordtype">unsigned</span> type   = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a26b9e6cfcf2f50db0805689b9e538bdc">ccnxCodecTlvDecoder_GetType</a>(decoder);</div><div class="line">     <span class="keywordtype">unsigned</span> length = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a7462962a9d507de768607080c68bdc33">ccnxCodecTlvDecoder_GetLength</a>(decoder);</div><div class="line">     <span class="keywordflow">if</span> (type == 3) {</div><div class="line">         CCNxCodecTlvDecoder *innerDecoder = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ab1ebe9d8a9c9b98449faa527dd58c955">ccnxCodecTlvDecoder_GetContainer</a>(decoder, length);</div><div class="line">         <span class="keywordflow">while</span> ( ! <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae72c49e1956ea30390d7c7ee69620bfb">ccnxCodecTlvDecoder_IsEmpty</a>(innerDecoder) ) {</div><div class="line">             type = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a26b9e6cfcf2f50db0805689b9e538bdc">ccnxCodecTlvDecoder_GetType</a>(decoder);</div><div class="line">             length = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a7462962a9d507de768607080c68bdc33">ccnxCodecTlvDecoder_GetLength</a>(decoder);</div><div class="line">             <span class="keywordflow">if</span> (type == 1) {</div><div class="line">                 PARCBuffer *name = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">                 <span class="comment">// use name, then release it</span></div><div class="line">             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == 2) {</div><div class="line">                 PARCBuffer *address = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">                 <span class="comment">// use address, then release it</span></div><div class="line">             }</div><div class="line">         }</div><div class="line">         <a class="code" href="ccnx_codec___tlv_decoder_8h.html#a974cebf8dcf1db78407db5a4804bcb76">ccnxCodecTlvDecoder_Destroy</a>(&amp;innerDecoder);</div><div class="line">     }</div><div class="line">     PARCReadOnlyBuffer * value = <a class="code" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a>(decoder, length);</div><div class="line">}</div></div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Marc Mosko, Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2013-2015, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;parc/algol/parc_Buffer.h&gt;</code><br />
<code>#include &lt;<a class="el" href="ccnx_codec___network_buffer_8h_source.html">ccnx/common/codec/ccnxCodec_NetworkBuffer.h</a>&gt;</code><br />
<code>#include &lt;parc/security/parc_Signer.h&gt;</code><br />
<code>#include &lt;parc/security/parc_Signature.h&gt;</code><br />
<code>#include &lt;<a class="el" href="ccnx_codec___error_8h_source.html">ccnx/common/codec/ccnxCodec_Error.h</a>&gt;</code><br />
</div>
<p><a href="ccnx_codec___tlv_decoder_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a72997719140167a7b42447834ce0e1ba"><td class="memItemLeft" align="right" valign="top">CCNxCodecTlvDecoder *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a72997719140167a7b42447834ce0e1ba">ccnxCodecTlvDecoder_Create</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a72997719140167a7b42447834ce0e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a TLV-encoded buffer to individual buffers for each Value.  <a href="#a72997719140167a7b42447834ce0e1ba">More...</a><br /></td></tr>
<tr class="separator:a72997719140167a7b42447834ce0e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974cebf8dcf1db78407db5a4804bcb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a974cebf8dcf1db78407db5a4804bcb76">ccnxCodecTlvDecoder_Destroy</a> (CCNxCodecTlvDecoder **decoderPtr)</td></tr>
<tr class="memdesc:a974cebf8dcf1db78407db5a4804bcb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the tlv decoder.  <a href="#a974cebf8dcf1db78407db5a4804bcb76">More...</a><br /></td></tr>
<tr class="separator:a974cebf8dcf1db78407db5a4804bcb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72c49e1956ea30390d7c7ee69620bfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#ae72c49e1956ea30390d7c7ee69620bfb">ccnxCodecTlvDecoder_IsEmpty</a> (CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:ae72c49e1956ea30390d7c7ee69620bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if there is anything left to decode.  <a href="#ae72c49e1956ea30390d7c7ee69620bfb">More...</a><br /></td></tr>
<tr class="separator:ae72c49e1956ea30390d7c7ee69620bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbff119511bcd479610ae0fedb03b3e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#afbff119511bcd479610ae0fedb03b3e4">ccnxCodecTlvDecoder_EnsureRemaining</a> (CCNxCodecTlvDecoder *decoder, size_t bytes)</td></tr>
<tr class="memdesc:afbff119511bcd479610ae0fedb03b3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are at least `bytes' bytes remaining in the buffer.  <a href="#afbff119511bcd479610ae0fedb03b3e4">More...</a><br /></td></tr>
<tr class="separator:afbff119511bcd479610ae0fedb03b3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ad0b8011ec9942689caaba8a20b6f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a96ad0b8011ec9942689caaba8a20b6f6">ccnxCodecTlvDecoder_Remaining</a> (const CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:a96ad0b8011ec9942689caaba8a20b6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bytes remaining in the decoder.  <a href="#a96ad0b8011ec9942689caaba8a20b6f6">More...</a><br /></td></tr>
<tr class="separator:a96ad0b8011ec9942689caaba8a20b6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b9e6cfcf2f50db0805689b9e538bdc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a26b9e6cfcf2f50db0805689b9e538bdc">ccnxCodecTlvDecoder_GetType</a> (CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:a26b9e6cfcf2f50db0805689b9e538bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next bytes as the TLV type.  <a href="#a26b9e6cfcf2f50db0805689b9e538bdc">More...</a><br /></td></tr>
<tr class="separator:a26b9e6cfcf2f50db0805689b9e538bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0926cef0540262b348a9924caedd0451"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a0926cef0540262b348a9924caedd0451">ccnxCodecTlvDecoder_PeekType</a> (CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:a0926cef0540262b348a9924caedd0451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the TLV Type but does not advance the decoder.  <a href="#a0926cef0540262b348a9924caedd0451">More...</a><br /></td></tr>
<tr class="separator:a0926cef0540262b348a9924caedd0451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7462962a9d507de768607080c68bdc33"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a7462962a9d507de768607080c68bdc33">ccnxCodecTlvDecoder_GetLength</a> (CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:a7462962a9d507de768607080c68bdc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next bytes as the TLV length.  <a href="#a7462962a9d507de768607080c68bdc33">More...</a><br /></td></tr>
<tr class="separator:a7462962a9d507de768607080c68bdc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75b55f528a9536c54cf9c77c2f45335"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#ae75b55f528a9536c54cf9c77c2f45335">ccnxCodecTlvDecoder_GetValue</a> (CCNxCodecTlvDecoder *decoder, uint16_t length)</td></tr>
<tr class="memdesc:ae75b55f528a9536c54cf9c77c2f45335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next `length' bytes as a value.  <a href="#ae75b55f528a9536c54cf9c77c2f45335">More...</a><br /></td></tr>
<tr class="separator:ae75b55f528a9536c54cf9c77c2f45335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39857b9ed24be68242aa10cbacc01562"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a39857b9ed24be68242aa10cbacc01562">ccnxCodecTlvDecoder_GetBuffer</a> (CCNxCodecTlvDecoder *decoder, uint16_t type)</td></tr>
<tr class="memdesc:a39857b9ed24be68242aa10cbacc01562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure the current position is of type `type', then return a buffer of the value.  <a href="#a39857b9ed24be68242aa10cbacc01562">More...</a><br /></td></tr>
<tr class="separator:a39857b9ed24be68242aa10cbacc01562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebe9d8a9c9b98449faa527dd58c955"><td class="memItemLeft" align="right" valign="top">CCNxCodecTlvDecoder *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#ab1ebe9d8a9c9b98449faa527dd58c955">ccnxCodecTlvDecoder_GetContainer</a> (CCNxCodecTlvDecoder *decoder, uint16_t length)</td></tr>
<tr class="memdesc:ab1ebe9d8a9c9b98449faa527dd58c955"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current location is a TLV container (a value that is TLVs)  <a href="#ab1ebe9d8a9c9b98449faa527dd58c955">More...</a><br /></td></tr>
<tr class="separator:ab1ebe9d8a9c9b98449faa527dd58c955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217ac64e8e12813777a583bca452e796"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a217ac64e8e12813777a583bca452e796">ccnxCodecTlvDecoder_GetUint8</a> (CCNxCodecTlvDecoder *decoder, uint16_t type, uint8_t *output)</td></tr>
<tr class="memdesc:a217ac64e8e12813777a583bca452e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the current location as a type, length, and uint8_t value.  <a href="#a217ac64e8e12813777a583bca452e796">More...</a><br /></td></tr>
<tr class="separator:a217ac64e8e12813777a583bca452e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64a6ade91242bd6ed6c93cfaed87cfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#aa64a6ade91242bd6ed6c93cfaed87cfa">ccnxCodecTlvDecoder_GetUint16</a> (CCNxCodecTlvDecoder *decoder, uint16_t type, uint16_t *output)</td></tr>
<tr class="memdesc:aa64a6ade91242bd6ed6c93cfaed87cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the current location as a type, length, and uint16_t value.  <a href="#aa64a6ade91242bd6ed6c93cfaed87cfa">More...</a><br /></td></tr>
<tr class="separator:aa64a6ade91242bd6ed6c93cfaed87cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e5a67643e0884bdb4438d5fe22b17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#aa44e5a67643e0884bdb4438d5fe22b17">ccnxCodecTlvDecoder_GetUint32</a> (CCNxCodecTlvDecoder *decoder, uint16_t type, uint32_t *output)</td></tr>
<tr class="memdesc:aa44e5a67643e0884bdb4438d5fe22b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the current location as a type, length, and uint32_t value.  <a href="#aa44e5a67643e0884bdb4438d5fe22b17">More...</a><br /></td></tr>
<tr class="separator:aa44e5a67643e0884bdb4438d5fe22b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447f080b34a8c8891873359d7e703d14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a447f080b34a8c8891873359d7e703d14">ccnxCodecTlvDecoder_GetUint64</a> (CCNxCodecTlvDecoder *decoder, uint16_t type, uint64_t *output)</td></tr>
<tr class="memdesc:a447f080b34a8c8891873359d7e703d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the current location as a type, length, and uint64_t value.  <a href="#a447f080b34a8c8891873359d7e703d14">More...</a><br /></td></tr>
<tr class="separator:a447f080b34a8c8891873359d7e703d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab120fa0862053823e3ba4cbf8cd43da6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#ab120fa0862053823e3ba4cbf8cd43da6">ccnxCodecTlvDecoder_Position</a> (CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:ab120fa0862053823e3ba4cbf8cd43da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current byte position of the buffer.  <a href="#ab120fa0862053823e3ba4cbf8cd43da6">More...</a><br /></td></tr>
<tr class="separator:ab120fa0862053823e3ba4cbf8cd43da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10c27ff5bdc4b66d53313d0f4d62907"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#ae10c27ff5bdc4b66d53313d0f4d62907">ccnxCodecTlvDecoder_Advance</a> (CCNxCodecTlvDecoder *decoder, uint16_t length)</td></tr>
<tr class="memdesc:ae10c27ff5bdc4b66d53313d0f4d62907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the decoder a given number of bytes.  <a href="#ae10c27ff5bdc4b66d53313d0f4d62907">More...</a><br /></td></tr>
<tr class="separator:ae10c27ff5bdc4b66d53313d0f4d62907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e92e24133ee722f18e2d7574719adaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a5e92e24133ee722f18e2d7574719adaf">ccnxCodecTlvDecoder_GetVarInt</a> (CCNxCodecTlvDecoder *decoder, uint16_t length, uint64_t *output)</td></tr>
<tr class="memdesc:a5e92e24133ee722f18e2d7574719adaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the current position as a VarInt.  <a href="#a5e92e24133ee722f18e2d7574719adaf">More...</a><br /></td></tr>
<tr class="separator:a5e92e24133ee722f18e2d7574719adaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd6f9e48b46dfa85acf4a3eb934d77b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a7fd6f9e48b46dfa85acf4a3eb934d77b">ccnxCodecTlvDecoder_BufferToVarInt</a> (PARCBuffer *buffer, uint16_t length, uint64_t *output)</td></tr>
<tr class="memdesc:a7fd6f9e48b46dfa85acf4a3eb934d77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the current position of the Buffer as a VarInt out to 'length' bytes.  <a href="#a7fd6f9e48b46dfa85acf4a3eb934d77b">More...</a><br /></td></tr>
<tr class="separator:a7fd6f9e48b46dfa85acf4a3eb934d77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63967bc3f265bbf4dbb1c074d1a3130c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#a63967bc3f265bbf4dbb1c074d1a3130c">ccnxCodecTlvDecoder_HasError</a> (const CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:a63967bc3f265bbf4dbb1c074d1a3130c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the TLV Encoder has an error condition set.  <a href="#a63967bc3f265bbf4dbb1c074d1a3130c">More...</a><br /></td></tr>
<tr class="separator:a63967bc3f265bbf4dbb1c074d1a3130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc39f31786f24a353f121be178466e64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#afc39f31786f24a353f121be178466e64">ccnxCodecTlvDecoder_SetError</a> (CCNxCodecTlvDecoder *decoder, CCNxCodecError *error)</td></tr>
<tr class="memdesc:afc39f31786f24a353f121be178466e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an error condition.  <a href="#afc39f31786f24a353f121be178466e64">More...</a><br /></td></tr>
<tr class="separator:afc39f31786f24a353f121be178466e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaf7c35d81911da5677e683c5507406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#aedaf7c35d81911da5677e683c5507406">ccnxCodecTlvDecoder_ClearError</a> (CCNxCodecTlvDecoder *decoder)</td></tr>
<tr class="memdesc:aedaf7c35d81911da5677e683c5507406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the error condition, if any.  <a href="#aedaf7c35d81911da5677e683c5507406">More...</a><br /></td></tr>
<tr class="separator:aedaf7c35d81911da5677e683c5507406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55a835d81809ec5c6c5b811dd761c4d"><td class="memItemLeft" align="right" valign="top">CCNxCodecError *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_decoder_8h.html#aa55a835d81809ec5c6c5b811dd761c4d">ccnxCodecTlvDecoder_GetError</a> (const CCNxCodecTlvDecoder *encoder)</td></tr>
<tr class="memdesc:aa55a835d81809ec5c6c5b811dd761c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the error message.  <a href="#aa55a835d81809ec5c6c5b811dd761c4d">More...</a><br /></td></tr>
<tr class="separator:aa55a835d81809ec5c6c5b811dd761c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae10c27ff5bdc4b66d53313d0f4d62907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_Advance </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the decoder a given number of bytes. </p>
<p>Advance the decoder, throwing away a given number of bytes. If there are not enough bytes left in the decoder, no action is taken</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder to advance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes to skip</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Advanced the buffer </dd>
<dd>
false Error, likely a buffer underrun (not enough bytes)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7fd6f9e48b46dfa85acf4a3eb934d77b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_BufferToVarInt </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the current position of the Buffer as a VarInt out to 'length' bytes. </p>
<p>A VarInt may be 1 to 8 bytes long. It is interpreted as an unsigned integer in network byte order. The buffer must have at least 'length' bytes remaining. The buffer is advanced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The TLV decoder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes in the varint </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The value of the varint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Successful decode </dd>
<dd>
fale Error (length too long, too short, or not enough bytes in decoder)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *buffer = parcBuffer_Wrap((uint8_t[]) { 0x10, 0x23, 0x00 }, 3, 0, 3 );</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     uint64_t value;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     ccnxCodecTlvDecoder_BufferToVarInt(buffer, 3, &amp;value);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     // value = 0x0000000000102300</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aedaf7c35d81911da5677e683c5507406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecTlvDecoder_ClearError </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the error condition, if any. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a72997719140167a7b42447834ce0e1ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecTlvDecoder* ccnxCodecTlvDecoder_Create </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes a TLV-encoded buffer to individual buffers for each Value. </p>
<p>Walks through a TLV-encoded buffer returning buffer slices of the original. These are 0-copy operations.</p>
<p>The decoder should be based on the CCNxCodecNetworkBufferIoVec, see case 1009</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to parse, must be ready to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null A TLV decoder </dd>
<dd>
null An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     ccnxCodecTlvDecoder_Destroy(&amp;decoder);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a974cebf8dcf1db78407db5a4804bcb76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxCodecTlvDecoder_Destroy </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder **&#160;</td>
          <td class="paramname"><em>decoderPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the tlv decoder. </p>
<p>Buffers that have been previously returned remain acquired. The internal reference to the input buffer will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoderPtr</td><td>Pointer to the decoder to destroy</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     ccnxCodecTlvDecoder_Destroy(&amp;decoder);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afbff119511bcd479610ae0fedb03b3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_EnsureRemaining </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there are at least `bytes' bytes remaining in the buffer. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true There are at least `bytes' bytes left </dd>
<dd>
false Buffer underrun</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a39857b9ed24be68242aa10cbacc01562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* ccnxCodecTlvDecoder_GetBuffer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure the current position is of type `type', then return a buffer of the value. </p>
<p>If the buffer points to a type of `type', the function will create a buffer of the specified length and return the value in a buffer.</p>
<p>The function will return NULL if the types don't match or if there is a a decoder underrun (its not as long as the type specifies), or if the length would take the end of the input buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The TLV decoder object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type type to validate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null A conforming buffer </dd>
<dd>
null An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     // GetBuffer                                     |--------------------------------------------|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;     PARCBuffer *buffer = ccnxCodecTlvDecoder_GetBuffer(decoder, 0xAABB);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     // buffer contains { 0x01, 0x02, 0x03, 0x04 }</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab1ebe9d8a9c9b98449faa527dd58c955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecTlvDecoder* ccnxCodecTlvDecoder_GetContainer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current location is a TLV container (a value that is TLVs) </p>
<p>Returns a TLV decoder that represents the "slice" of the input buffer from the current position up to the current position plus `length'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null A new sub-decoder </dd>
<dd>
null An error, such as input underrun</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     // GetType                                       |--------|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     // GetLength                                                 |--------|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     // GetContainer                                                          |--------------------------------------------|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     // GetBuffer                                                             |--------------------------------------------|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0x00, 0x01, 0x00, 0x08, 0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 12, 0, 12);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;     uint16_t containerType = ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;     size_t containerLength = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;     CCNxCodecTlvDecoder *innerDecoder = ccnxCodecTlvDecoder_GetContainer(decoder, containerLength);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;     PARCBuffer *buffer = ccnxCodecTlvDecoder_GetBuffer(decoder, 0xAABB);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;     ccnxCodecTlvDecoder_Destroy(&amp;innerDecoder);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;     ccnxCodecTlvDecoder_Destroy(&amp;decoder);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;     // buffer contains { 0x01, 0x02, 0x03, 0x04 }</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa55a835d81809ec5c6c5b811dd761c4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxCodecError* ccnxCodecTlvDecoder_GetError </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the error message. </p>
<p>Retrieves the error condition, if any. If no error is set, will return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-null The error condition set </dd>
<dd>
null No error condition is set</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7462962a9d507de768607080c68bdc33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ccnxCodecTlvDecoder_GetLength </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next bytes as the TLV length. </p>
<p>The buffer is advanced the width of the length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     // GetType                                       |--------|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     // GetLength                                                 |--------|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     // GetValue                                                              |--------------------|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;     unsigned type   = ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     unsigned length = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     PARCBuffer * value = ccnxCodecTlvDecoder_GetValue(decoder, length);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;     // value = 0x01020304</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a26b9e6cfcf2f50db0805689b9e538bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ccnxCodecTlvDecoder_GetType </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next bytes as the TLV type. </p>
<p>The buffer is advanced the width of the type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     // GetType                                       |--------|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     // GetLength                                                 |--------|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     // GetValue                                                              |--------------------|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;     unsigned type   = ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     unsigned length = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     PARCBuffer * value = ccnxCodecTlvDecoder_GetValue(decoder, length);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;     // value = 0x01020304</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa64a6ade91242bd6ed6c93cfaed87cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_GetUint16 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the current location as a type, length, and uint16_t value. </p>
<p>Ensures the type is `type' and returns the value as a uint16_t. If the type does not match or there is buffer underflow, the function will return false and the output will be unchanged. If the TLV length is not "2", it will also return false. Otherwise, it returns true and the decoded value.</p>
<p>On success, the decoder is advanced, on failure the decoder will remain at the current position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The TLV type to validate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The output value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true output parameter is valid </dd>
<dd>
false on error (type did not match or buffer underflow)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *buffer = parcBuffer_Wrap((uint8_t[]) { 0x10, 0x21, 0x00, 0x02, 0xFF, 0xAA }, 6, 0, 6 );</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     uint16_t value;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     bool success = ccnxCodecTlvDecoder_GetUint16(decoder, 0x1021, &amp;value);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     assert(success &amp;&amp; value == 0xFFAA);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa44e5a67643e0884bdb4438d5fe22b17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_GetUint32 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the current location as a type, length, and uint32_t value. </p>
<p>Ensures the type is `type' and returns the value as a uint32_t. If the type does not match or there is buffer underflow, the function will return false and the output will be unchanged. If the TLV length is not "4", it will also return false. Otherwise, it returns true and the decoded value.</p>
<p>On success, the decoder is advanced, on failure the decoder will remain at the current position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The TLV type to validate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The output value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true output parameter is valid </dd>
<dd>
false on error (type did not match or buffer underflow)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *buffer = parcBuffer_Wrap((uint8_t[]) { 0x10, 0x22, 0x00, 0x04, 0xFF, 0xAA, 0xBB, 0xCC }, 8, 0, 8 );</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     uint32_t value;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     bool success = ccnxCodecTlvDecoder_GetUint32(decoder, 0x1022, &amp;value);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     assert(success &amp;&amp; value == 0xFFAABBCC);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a447f080b34a8c8891873359d7e703d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_GetUint64 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the current location as a type, length, and uint64_t value. </p>
<p>Ensures the type is `type' and returns the value as a uint64_t. If the type does not match or there is buffer underflow, the function will return false and the output will be unchanged. If the TLV length is not "8", it will also return false. Otherwise, it returns true and the decoded value.</p>
<p>On success, the decoder is advanced, on failure the decoder will remain at the current position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The TLV type to validate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The output value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true output parameter is valid </dd>
<dd>
false on error (type did not match or buffer underflow)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *buffer = parcBuffer_Wrap((uint8_t[]) { 0x10, 0x23, 0x00, 0x08, 0xFF, 0xAA, 0xBB, 0xCC, 0x00, 0x00, 0x00, 0x00 }, 12, 0, 12 );</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     uint64_t value;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     bool success = ccnxCodecTlvDecoder_GetUint64(decoder, 0x1023, &amp;value);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     assert(success &amp;&amp; value == 0xFFAABBCC00000000ULL);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a217ac64e8e12813777a583bca452e796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_GetUint8 </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the current location as a type, length, and uint8_t value. </p>
<p>Ensures the type is `type' and returns the value as a uint8_t. If the type does not match or there is buffer underflow, the function will return false and the output will be unchanged. If the TLV length is not "1", it will also return false. Otherwise, it returns true and the decoded value.</p>
<p>On success, the decoder is advanced, on failure the decoder will remain at the current position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The TLV type to validate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The output value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true output parameter is valid </dd>
<dd>
false on error (type did not match or buffer underflow)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *buffer = parcBuffer_Wrap((uint8_t[]) { 0x10, 0x20, 0x00, 0x01, 0xFF }, 5, 0, 5 );</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     uint8_t value;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     bool success = ccnxCodecTlvDecoder_GetUint8(decoder, 0x1020, &amp;value);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     assert(success &amp;&amp; value == 0xFF);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae75b55f528a9536c54cf9c77c2f45335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* ccnxCodecTlvDecoder_GetValue </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next `length' bytes as a value. </p>
<p>The buffer is advanced `length' bytes. The returned value is ready for reading.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     // GetType                                       |--------|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     // GetLength                                                 |--------|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     // GetValue                                                              |--------------------|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;     unsigned type   = ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     unsigned length = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     PARCBuffer * value = ccnxCodecTlvDecoder_GetValue(decoder, length);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;     // value = 0x01020304</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5e92e24133ee722f18e2d7574719adaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_GetVarInt </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the current position as a VarInt. </p>
<p>A VarInt may be 1 to 8 bytes long. It is interpreted as an unsigned integer in network byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The TLV decoder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes in the varint </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The value of the varint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Successful decode </dd>
<dd>
fale Error (length too long, too short, or not enough bytes in decoder)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *buffer = parcBuffer_Wrap((uint8_t[]) { 0x10, 0x23, 0x00 }, 3, 0, 3 );</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     uint64_t value;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     ccnxCodecTlvDecoder_GetVarInt(decoder, 3, &amp;value);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     // value = 0x0000000000102300</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a63967bc3f265bbf4dbb1c074d1a3130c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_HasError </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the TLV Encoder has an error condition set. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae72c49e1956ea30390d7c7ee69620bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_IsEmpty </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if there is anything left to decode. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true There are more bytes available </dd>
<dd>
false At the end of the buffer</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0926cef0540262b348a9924caedd0451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ccnxCodecTlvDecoder_PeekType </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the TLV Type but does not advance the decoder. </p>
<p>At the current position, decode the next bytes as the TLV type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The Decoder object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number The TLV type</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     // PeekType                                      |--------|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     // GetType                                       |--------|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     // GetLength                                                 |--------|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     // GetValue                                                              |--------------------|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     PARCBuffer *input = parcBuffer_Wrap((uint8_t[]) {0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;     CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     unsigned type   = ccnxCodecTlvDecoder_PeekType(decoder);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     if( type == 0xAABB ) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        (void) ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        unsigned length = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;         PARCBuffer * value = ccnxCodecTlvDecoder_GetValue(decoder, length);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;         // value = 0x01020304</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;     }</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab120fa0862053823e3ba4cbf8cd43da6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccnxCodecTlvDecoder_Position </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current byte position of the buffer. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a96ad0b8011ec9942689caaba8a20b6f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccnxCodecTlvDecoder_Remaining </td>
          <td>(</td>
          <td class="paramtype">const CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bytes remaining in the decoder. </p>
<p>The remaining bytes to be decoded</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>An allocated decoder</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">number</td><td>The bytes left to decode</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afc39f31786f24a353f121be178466e64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvDecoder_SetError </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxCodecError *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an error condition. </p>
<p>Only one error condition may be set.</p>
<p>Stores a reference counted copy of the CCNxCodecError. If an error is already set, this function returns false and does not store a reference count. The previous error stays as the current error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Error condition set </dd>
<dd>
false Error already set, you must clear it first</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright  2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Mon Aug 29 2016 12:44:52
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084575; 
var sc_invisible=0;
var sc_security="bed914f8"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" src="http://c.statcounter.com/11084575/0/bed914f8/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>

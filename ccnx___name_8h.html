<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>CCNx Common Library: /Users/gscott/Documents/workspace/CCNx_Distillery-Gatekeeper/CCNx_Distillery/src/Libccnx-common/ccnx/common/ccnx_Name.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">CCNx Common Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_16fe5a6cb4619b62438c1360066364fb.html">Libccnx-common</a></li><li class="navelem"><a class="el" href="dir_ca999156402b63f07c663b5e9508e272.html">ccnx</a></li><li class="navelem"><a class="el" href="dir_0ce23f429e33a65a4627580fe4574273.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ccnx_Name.h File Reference<div class="ingroups"><a class="el" href="group___naming.html">CCN Naming</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The basic CCNx Name.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The basic CCNx Name. </p>
<p>This implements an RFC3986 URI compliant identifier in which each path segment carries a label. This allows differentiation between resources with otherwise similar identifiers that are not related. For example, one resource could be named <code>"/parc/csl/7"</code> meaning the 7th version of <code>"/parc/csl"</code>, while another could mean the 7th page of the resource. With labeled segments, the two resources would have unambiguous names, such as <code>"/parc/csl/version=7"</code> and <code>"/parc/csl/page=7"</code>.</p>
<dl class="section author"><dt>Author</dt><dd>Glenn Scott, Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2013-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;parc/algol/parc_HashCode.h&gt;</code><br />
<code>#include &lt;<a class="el" href="ccnx___name_segment_8h_source.html">ccnx/common/ccnx_NameSegment.h</a>&gt;</code><br />
</div>
<p><a href="ccnx___name_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6ce68b70306fb39c5226ec58cae6e2d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce68b70306fb39c5226ec58cae6e2d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ccnxName_OptionalAssertValid</b>(_instance_)&#160;&#160;&#160;<a class="el" href="ccnx___name_8h.html#a0032e699d659e1e3a1916f486eba93e7">ccnxName_AssertValid</a>(_instance_)</td></tr>
<tr class="separator:a6ce68b70306fb39c5226ec58cae6e2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af75e5a553729be008b5705283f92a7aa"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#af75e5a553729be008b5705283f92a7aa">ccnxName_CreateFromCString</a> (const char *uri)</td></tr>
<tr class="memdesc:af75e5a553729be008b5705283f92a7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>CCNxName</code>, initialized from the given string representation of an LCI URI, using dynamically allocated memory.  <a href="#af75e5a553729be008b5705283f92a7aa">More...</a><br /></td></tr>
<tr class="separator:af75e5a553729be008b5705283f92a7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a1ee0584f607a67bc0456cbfa36d8d"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a27a1ee0584f607a67bc0456cbfa36d8d">ccnxName_FromURI</a> (const PARCURI *uri)</td></tr>
<tr class="memdesc:a27a1ee0584f607a67bc0456cbfa36d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>CCNxName</code>, initialized from the given <code>PARCURI</code> representation of an LCI URI, using dynamically allocated memory.  <a href="#a27a1ee0584f607a67bc0456cbfa36d8d">More...</a><br /></td></tr>
<tr class="separator:a27a1ee0584f607a67bc0456cbfa36d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaf24bdd0ba52e2f2caee32ca63e8c5"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#afcaf24bdd0ba52e2f2caee32ca63e8c5">ccnxName_CreateFormatString</a> (const char *restrict format,...)</td></tr>
<tr class="memdesc:afcaf24bdd0ba52e2f2caee32ca63e8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>CCNxName</code> from the given format string and variable number of parameters.  <a href="#afcaf24bdd0ba52e2f2caee32ca63e8c5">More...</a><br /></td></tr>
<tr class="separator:afcaf24bdd0ba52e2f2caee32ca63e8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19979bf3bb6cf4c8916ed2123d04490a"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a19979bf3bb6cf4c8916ed2123d04490a">ccnxName_CreateFromBuffer</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a19979bf3bb6cf4c8916ed2123d04490a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>CCNxName</code>, initialized from a string representation of a LCI URI contained in the given PARCBuffer, starting at the current position and terminating with a zero-byte in the buffer.  <a href="#a19979bf3bb6cf4c8916ed2123d04490a">More...</a><br /></td></tr>
<tr class="separator:a19979bf3bb6cf4c8916ed2123d04490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20a8297b9a2c04b429010005ed1ff39"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ac20a8297b9a2c04b429010005ed1ff39">ccnxName_Acquire</a> (const CCNxName *name)</td></tr>
<tr class="memdesc:ac20a8297b9a2c04b429010005ed1ff39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of references to a <code>CCNxName</code> instance.  <a href="#ac20a8297b9a2c04b429010005ed1ff39">More...</a><br /></td></tr>
<tr class="separator:ac20a8297b9a2c04b429010005ed1ff39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20a808b6b88bd966718e7878cb3f588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588">ccnxName_Release</a> (CCNxName **nameP)</td></tr>
<tr class="memdesc:ad20a808b6b88bd966718e7878cb3f588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired reference to the specified instance, decrementing the reference count for the instance.  <a href="#ad20a808b6b88bd966718e7878cb3f588">More...</a><br /></td></tr>
<tr class="separator:ad20a808b6b88bd966718e7878cb3f588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0032e699d659e1e3a1916f486eba93e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a0032e699d659e1e3a1916f486eba93e7">ccnxName_AssertValid</a> (const CCNxName *name)</td></tr>
<tr class="memdesc:a0032e699d659e1e3a1916f486eba93e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that an instance of <code>CCNxName</code> is valid.  <a href="#a0032e699d659e1e3a1916f486eba93e7">More...</a><br /></td></tr>
<tr class="separator:a0032e699d659e1e3a1916f486eba93e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabd6857a3c879d20a03781362be85fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#aaabd6857a3c879d20a03781362be85fd">ccnxName_IsValid</a> (const CCNxName *name)</td></tr>
<tr class="memdesc:aaabd6857a3c879d20a03781362be85fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an instance of <code>CCNxName</code> is valid.  <a href="#aaabd6857a3c879d20a03781362be85fd">More...</a><br /></td></tr>
<tr class="separator:aaabd6857a3c879d20a03781362be85fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c53396325316a6f917d6269491d750"><td class="memItemLeft" align="right" valign="top">PARCBufferComposer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a02c53396325316a6f917d6269491d750">ccnxName_BuildString</a> (const CCNxName *name, PARCBufferComposer *composer)</td></tr>
<tr class="memdesc:a02c53396325316a6f917d6269491d750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a representation of the specified <code>CCNxName</code> instance to the given <a class="el" href="">PARCBufferComposer</a>.  <a href="#a02c53396325316a6f917d6269491d750">More...</a><br /></td></tr>
<tr class="separator:a02c53396325316a6f917d6269491d750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dac03639080c1d5d82c6e492d8ea5a5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a4dac03639080c1d5d82c6e492d8ea5a5">ccnxName_ToString</a> (const CCNxName *name)</td></tr>
<tr class="memdesc:a4dac03639080c1d5d82c6e492d8ea5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a null-terminated string representation of the specified instance.  <a href="#a4dac03639080c1d5d82c6e492d8ea5a5">More...</a><br /></td></tr>
<tr class="separator:a4dac03639080c1d5d82c6e492d8ea5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74036b551c2f50d8a3570bcb136b9a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a74036b551c2f50d8a3570bcb136b9a46">ccnxName_Display</a> (const CCNxName *name, int indentation)</td></tr>
<tr class="memdesc:a74036b551c2f50d8a3570bcb136b9a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a human readable representation of the given <code>CCNxName</code>.  <a href="#a74036b551c2f50d8a3570bcb136b9a46">More...</a><br /></td></tr>
<tr class="separator:a74036b551c2f50d8a3570bcb136b9a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafec860cfa71f9ed46deb48a34ffaac"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#abafec860cfa71f9ed46deb48a34ffaac">ccnxName_Append</a> (CCNxName *name, const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:abafec860cfa71f9ed46deb48a34ffaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a <a class="el" href="">CCNxNameSegment</a> to the given <code>CCNxName</code>.  <a href="#abafec860cfa71f9ed46deb48a34ffaac">More...</a><br /></td></tr>
<tr class="separator:abafec860cfa71f9ed46deb48a34ffaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad866c2890b8ea020d1fe3213a803d8e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ad866c2890b8ea020d1fe3213a803d8e8">ccnxName_StartsWith</a> (const CCNxName *name, const CCNxName *prefix)</td></tr>
<tr class="memdesc:ad866c2890b8ea020d1fe3213a803d8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a <code>CCNxName</code> is starts with another.  <a href="#ad866c2890b8ea020d1fe3213a803d8e8">More...</a><br /></td></tr>
<tr class="separator:ad866c2890b8ea020d1fe3213a803d8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac194310c59eb2e3cb08566ce2c21c517"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ac194310c59eb2e3cb08566ce2c21c517">ccnxName_Copy</a> (const CCNxName *originalName)</td></tr>
<tr class="memdesc:ac194310c59eb2e3cb08566ce2c21c517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the specified <code>CCNxName</code> instance, producing a new, independent, instance from dynamically allocated memory.  <a href="#ac194310c59eb2e3cb08566ce2c21c517">More...</a><br /></td></tr>
<tr class="separator:ac194310c59eb2e3cb08566ce2c21c517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dcfc9fdc61106a998fb04bf4f4371f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ae0dcfc9fdc61106a998fb04bf4f4371f">ccnxName_Equals</a> (const CCNxName *name1, const CCNxName *name2)</td></tr>
<tr class="memdesc:ae0dcfc9fdc61106a998fb04bf4f4371f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <code>CCNxName</code> instances are equal.  <a href="#ae0dcfc9fdc61106a998fb04bf4f4371f">More...</a><br /></td></tr>
<tr class="separator:ae0dcfc9fdc61106a998fb04bf4f4371f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae433e688e9ca8a712f96a0b8dba1e8fd"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ae433e688e9ca8a712f96a0b8dba1e8fd">ccnxName_Create</a> (void)</td></tr>
<tr class="memdesc:ae433e688e9ca8a712f96a0b8dba1e8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <code>CCNxName</code> object.  <a href="#ae433e688e9ca8a712f96a0b8dba1e8fd">More...</a><br /></td></tr>
<tr class="separator:ae433e688e9ca8a712f96a0b8dba1e8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45622ad214cc33e8217449d0a438f25b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a45622ad214cc33e8217449d0a438f25b">ccnxName_Compare</a> (const CCNxName *name1, const CCNxName *name2)</td></tr>
<tr class="memdesc:a45622ad214cc33e8217449d0a438f25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code>name1</code> to <code>name2</code> using CCNx canonical ordering (shortlex).  <a href="#a45622ad214cc33e8217449d0a438f25b">More...</a><br /></td></tr>
<tr class="separator:a45622ad214cc33e8217449d0a438f25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140e79eacfe8e9e2d0c7d40b16004f09"><td class="memItemLeft" align="right" valign="top">CCNxNameSegment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a140e79eacfe8e9e2d0c7d40b16004f09">ccnxName_GetSegment</a> (const CCNxName *name, size_t index)</td></tr>
<tr class="memdesc:a140e79eacfe8e9e2d0c7d40b16004f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <a class="el" href="">CCNxNameSegment</a> instance for the specified <code>CCNxName</code> at the given index.  <a href="#a140e79eacfe8e9e2d0c7d40b16004f09">More...</a><br /></td></tr>
<tr class="separator:a140e79eacfe8e9e2d0c7d40b16004f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa072270e38a5b382d28deb4a6afa7de5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#aa072270e38a5b382d28deb4a6afa7de5">ccnxName_GetSegmentCount</a> (const CCNxName *name)</td></tr>
<tr class="memdesc:aa072270e38a5b382d28deb4a6afa7de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <code>CCNxNameSegments</code> in the specified <code>CCNxName</code>.  <a href="#aa072270e38a5b382d28deb4a6afa7de5">More...</a><br /></td></tr>
<tr class="separator:aa072270e38a5b382d28deb4a6afa7de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c9f73c5e61c32880e9e01ef60a9ea6"><td class="memItemLeft" align="right" valign="top">PARCHashCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ac7c9f73c5e61c32880e9e01ef60a9ea6">ccnxName_HashCode</a> (const CCNxName *name)</td></tr>
<tr class="memdesc:ac7c9f73c5e61c32880e9e01ef60a9ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hashcode for the given <code>CCNxName</code>.  <a href="#ac7c9f73c5e61c32880e9e01ef60a9ea6">More...</a><br /></td></tr>
<tr class="separator:ac7c9f73c5e61c32880e9e01ef60a9ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aecfa6b4f4d2d94278e005effa536453b"><td class="memItemLeft" align="right" valign="top">PARCHashCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#aecfa6b4f4d2d94278e005effa536453b">ccnxName_LeftMostHashCode</a> (const CCNxName *name, size_t count)</td></tr>
<tr class="memdesc:aecfa6b4f4d2d94278e005effa536453b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hash of the leftmost <code>count</code> <a class="el" href="">CCNxNameSegment</a>s in a <code>CCNxName</code>.  <a href="#aecfa6b4f4d2d94278e005effa536453b">More...</a><br /></td></tr>
<tr class="separator:aecfa6b4f4d2d94278e005effa536453b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813f50e30be9bf49890431fb0ecc8c8d"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a813f50e30be9bf49890431fb0ecc8c8d">ccnxName_Trim</a> (CCNxName *name, size_t numberToRemove)</td></tr>
<tr class="memdesc:a813f50e30be9bf49890431fb0ecc8c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim <code>numberToRemove</code> segments from the end of the specified <code>CCNxName</code>.  <a href="#a813f50e30be9bf49890431fb0ecc8c8d">More...</a><br /></td></tr>
<tr class="separator:a813f50e30be9bf49890431fb0ecc8c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7b43fd992e74589beaf57bec8b38dc"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#aec7b43fd992e74589beaf57bec8b38dc">ccnxName_ComposeNAME</a> (const CCNxName *prefix, const char *suffix)</td></tr>
<tr class="memdesc:aec7b43fd992e74589beaf57bec8b38dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose a new CCNxName instance consisting of the given  appended with <code>suffix</code> as a <code>CCNxNameLabelType_NAME</code>.  <a href="#aec7b43fd992e74589beaf57bec8b38dc">More...</a><br /></td></tr>
<tr class="separator:aec7b43fd992e74589beaf57bec8b38dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1d43f5a4dd027883e1ae7ff8df0720"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#adc1d43f5a4dd027883e1ae7ff8df0720">ccnxName_GetNthSegmentNumber</a> (const CCNxName *name, size_t nthNumber)</td></tr>
<tr class="memdesc:adc1d43f5a4dd027883e1ae7ff8df0720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Nth segment number of the given <code>CCNxName</code>  <a href="#adc1d43f5a4dd027883e1ae7ff8df0720">More...</a><br /></td></tr>
<tr class="separator:adc1d43f5a4dd027883e1ae7ff8df0720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abdecee360a758d01b45ae67d59d07a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a9abdecee360a758d01b45ae67d59d07a">ccnxName_GetSegmentNumber</a> (const CCNxName *name)</td></tr>
<tr class="memdesc:a9abdecee360a758d01b45ae67d59d07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;#One Line Description#&gt;  <a href="#a9abdecee360a758d01b45ae67d59d07a">More...</a><br /></td></tr>
<tr class="separator:a9abdecee360a758d01b45ae67d59d07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47da974a17e9bbdea07649361fb826b"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#ab47da974a17e9bbdea07649361fb826b">ccnxName_ComposeFormatString</a> (const CCNxName *baseName, const char *restrict format,...)</td></tr>
<tr class="memdesc:ab47da974a17e9bbdea07649361fb826b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new CCNxName instance composed of the given CCNxName with the parsed result of the format string appended.  <a href="#ab47da974a17e9bbdea07649361fb826b">More...</a><br /></td></tr>
<tr class="separator:ab47da974a17e9bbdea07649361fb826b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef17e0b91cb4ba6feaf63ef27511630"><td class="memItemLeft" align="right" valign="top">CCNxName *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_8h.html#a3ef17e0b91cb4ba6feaf63ef27511630">ccnxName_CreatePrefix</a> (const CCNxName *name, size_t length)</td></tr>
<tr class="memdesc:a3ef17e0b91cb4ba6feaf63ef27511630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CCNxName that is a prefix of another.  <a href="#a3ef17e0b91cb4ba6feaf63ef27511630">More...</a><br /></td></tr>
<tr class="separator:a3ef17e0b91cb4ba6feaf63ef27511630"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac20a8297b9a2c04b429010005ed1ff39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_Acquire </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of references to a <code>CCNxName</code> instance. </p>
<p>Note that new <code>CCNxName</code> is not created, only that the given <code>CCNxName</code> reference count is incremented. Discard the reference by invoking <a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588">ccnxName_Release</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to the original <code>CCNxName</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the input parameter <code>name</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *original = ccnxName_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxName *reference = ccnxName_Acquire(original);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxName_Release(&amp;original);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxName_Release(&amp;reference);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588" title="Release a previously acquired reference to the specified instance, decrementing the reference count f...">ccnxName_Release</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abafec860cfa71f9ed46deb48a34ffaac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_Append </td>
          <td>(</td>
          <td class="paramtype">CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a <a class="el" href="">CCNxNameSegment</a> to the given <code>CCNxName</code>. </p>
<p>Append the <code>CCNxNameSegment</code> to the given <code>CCNxName</code>. The given <code>CCNxName</code> is modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">name</td><td>The base <code>CCNxName</code> to append the <code>segment</code> to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>The segment to append to <code>name</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modifed <code>name</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name1 = ccnxName_CreateFromCString(&quot;lci:/a/b/c/d&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxName *name2 = ccnxName_Create();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxNameSegment *segment = ccnxName_GetSegment(name1, 0);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxName_Append(name2, segment);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxName_Release(&amp;name1);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxName_Release(&amp;name2);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0032e699d659e1e3a1916f486eba93e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxName_AssertValid </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert that an instance of <code>CCNxName</code> is valid. </p>
<p>If the instance is not valid, terminate via <a class="el" href="">trapIllegalValue</a></p>
<p>Valid means the internal state of the type is consistent with its required current or future behaviour. This may include the validation of internal instances of types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to a <code>CCNxName</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/ccn/things/p1e&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxName_AssertValid(name);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a02c53396325316a6f917d6269491d750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBufferComposer* ccnxName_BuildString </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCBufferComposer *&#160;</td>
          <td class="paramname"><em>composer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a representation of the specified <code>CCNxName</code> instance to the given <a class="el" href="">PARCBufferComposer</a>. </p>
<p>The CCN URI representing the <a class="el" href="">CCNxNameSegment</a>'s associated with this <code>CCNxName</code> is appended to the supplied <a class="el" href="">PARCBufferComposer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to a <code>CCNxName</code> instance whose representation should be appended to the <code>composer</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">composer</td><td>A pointer to a <code>PARCBufferComposer</code> instance to be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Cannot allocate memory. </dd>
<dd>
non-NULL The <code>composer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBufferComposer *result = parcBufferComposer_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxName_BuildString(instance, result);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    char *string = parcBuffer_ToString(parcBufferComposer_ProduceBuffer(result));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    printf(&quot;Hello: %s\n&quot;, string);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcMemory_Deallocate(string);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBufferComposer_Release(&amp;result);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code>CCNxNameSegment</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a45622ad214cc33e8217449d0a438f25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccnxName_Compare </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare <code>name1</code> to <code>name2</code> using CCNx canonical ordering (shortlex). </p>
<p><code>NULL</code> is considered the shortest name, so <code>(NULL, non-NULL) -&gt; -1</code> and <code>(NULL, NULL) -&gt; 0</code>, <code>(non-NULL, NULL) -&gt; +1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name1</td><td>A pointer to a <code>CCNxName</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name2</td><td>A pointer to a <code>CCNxName</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p><ul>
<li>
-1 for name1 &lt; name2 </li>
<li>
0 for name1 = name2 </li>
<li>
+1 for name1 &gt; name2 </li>
</ul>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *orig = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/radiation/17&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxName *copy = ccnxName_Copy(orig);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (ccnxName_Compare(orig, copy)) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        ...</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxName_Release(&amp;orig);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxName_Release(&amp;copy);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_8h.html#ae0dcfc9fdc61106a998fb04bf4f4371f">ccnxName_Equals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab47da974a17e9bbdea07649361fb826b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_ComposeFormatString </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new CCNxName instance composed of the given CCNxName with the parsed result of the format string appended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseName</td><td>The base name of the new CCNxName </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>A printf(3) format string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a valid <code>CCNxName</code> segment. </dd>
<dd>
NULL The object could not be created.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aec7b43fd992e74589beaf57bec8b38dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_ComposeNAME </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose a new CCNxName instance consisting of the given  appended with <code>suffix</code> as a <code>CCNxNameLabelType_NAME</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A pointer to a valid CCNxName instance containing the prefix of the new name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A pointer to a nul-terminated C string that is appended to the new name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a valid CCNxName instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac194310c59eb2e3cb08566ce2c21c517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_Copy </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>originalName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of the specified <code>CCNxName</code> instance, producing a new, independent, instance from dynamically allocated memory. </p>
<p>This a deep copy. All referenced memory is copied. The created instance of <code>CCNxName</code> must be released by calling <a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588">ccnxName_Release</a>().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">originalName</td><td>The <code>CCNxName</code> to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new, independent copy of the given <code>CCNxName</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *originalName = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/radiation/17&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxName *copy = ccnxName_Copy(originalName);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxName_Release(&amp;originalName);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxName_Release(&amp;copy);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae433e688e9ca8a712f96a0b8dba1e8fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_Create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <code>CCNxName</code> object. </p>
<p>The instance is reference counted with an initial count of 1. Additional references are acquired via the function <a class="el" href="ccnx___name_8h.html#ac20a8297b9a2c04b429010005ed1ff39">ccnxName_Acquire</a> and these references are inidividually released via <a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588">ccnxName_Release</a></p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new instance of a <code>CCNxName</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afcaf24bdd0ba52e2f2caee32ca63e8c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_CreateFormatString </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>CCNxName</code> from the given format string and variable number of parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>A pointer to a nul-terminated printf format string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>A variable number of parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a valid CCNxName instance. </dd>
<dd>
NULL An error occurred.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFormatString(&quot;lci://%s/object&quot;, &quot;parc.com&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a19979bf3bb6cf4c8916ed2123d04490a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_CreateFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>CCNxName</code>, initialized from a string representation of a LCI URI contained in the given PARCBuffer, starting at the current position and terminating with a zero-byte in the buffer. </p>
<p>using dynamically allocated memory.</p>
<p>The URI must be a well-formed URI.</p>
<p>The <code>CCNxName</code> instance must be released by calling <a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588">ccnxName_Release</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>A null-terminated string representation of the CCNx Name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a <code>CCNxName</code> instance initialised from the given URI. </dd>
<dd>
NULL An error occured parsing the URI, or the URI contained an invalid specification.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_AllocateCString(&quot;lci:/parc/csl/media/h2162&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxName *name = ccnxName_CreateFromBuffer(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af75e5a553729be008b5705283f92a7aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_CreateFromCString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>CCNxName</code>, initialized from the given string representation of an LCI URI, using dynamically allocated memory. </p>
<p>The URI must be a well-formed URI.</p>
<p>The <code>CCNxName</code> instance must be released by calling <a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588">ccnxName_Release</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>A null-terminated string representation of the CCNx Name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a <code>CCNxName</code> instance initialised from the given URI. </dd>
<dd>
NULL An error occured parsing the URI, or the URI contained an invalid specification.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/media/h2162&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3ef17e0b91cb4ba6feaf63ef27511630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_CreatePrefix </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CCNxName that is a prefix of another. </p>
<p>If the specified length is greater than the number of segments available, the result is a new name that is a copy of the old name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to a valid <code>CCNxName</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of <code>CCNxNameSegments</code> the prefix must include.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a valid CCNxName. </dd>
<dd>
NULL An error occurred.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *a = ccnxName_CreateFromCString(&quot;ccnx:/a/b/c&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxName *prefix = ccnxName_CreatePrefix(a, 1);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // prefix is equal to the name &quot;ccnx:/a&quot;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxName_Release(&amp;a);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxName_Release(&amp;prefix);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxName_Release(&amp;actual);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a74036b551c2f50d8a3570bcb136b9a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxName_Display </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a human readable representation of the given <code>CCNxName</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to the <code>CCNxName</code> to display. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indentation</td><td>The level of indentation to use to pretty-print the output.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/radiation/11&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxInterest_Display(name, 0);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae0dcfc9fdc61106a998fb04bf4f4371f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxName_Equals </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <code>CCNxName</code> instances are equal. </p>
<p>The following equivalence relations on non-null <code>CCNxName</code> instances are maintained:</p>
<ul>
<li>It is reflexive: for any non-null reference value x, <code>ccnxName_Equals(x, x)</code> must return true.</li>
<li>It is symmetric: for any non-null reference values x and y, <code>ccnxName_Equals(x, y)</code> must return true if and only if <code>ccnxName_Equals(y x)</code> returns true.</li>
<li>It is transitive: for any non-null reference values x, y, and z, if <code>ccnxName_Equals(x, y)</code> returns true and <code>ccnxName_Equals(y, z)</code> returns true, then <code>ccnxName_Equals(x, z)</code> must return true.</li>
<li>It is consistent: for any non-null reference values x and y, multiple invocations of <code>ccnxName_Equals(x, y)</code> consistently return true or consistently return false.</li>
<li>For any non-null reference value x, <code>ccnxName_Equals(x, NULL)</code> must return false.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name1</td><td>A pointer to a <code>CCNxName</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name2</td><td>A pointer to a <code>CCNxName</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True If the given <code>CCNxName</code> instances are equal </dd>
<dd>
False Otherwise</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *orig = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/radiation/17&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxName *copy = ccnxName_Copy(orig);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (ccnxName_Equals(orig, copy)) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        // true</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    } else {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        // false</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     }</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxName_Release(&amp;orig);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ccnxName_Release(&amp;copy);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_8h.html#a45622ad214cc33e8217449d0a438f25b">ccnxName_Compare</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a27a1ee0584f607a67bc0456cbfa36d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_FromURI </td>
          <td>(</td>
          <td class="paramtype">const PARCURI *&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>CCNxName</code>, initialized from the given <code>PARCURI</code> representation of an LCI URI, using dynamically allocated memory. </p>
<p>The URI must be a well-formed LCI URI.</p>
<p>The <code>CCNxName</code> instance must be released by calling <a class="el" href="ccnx___name_8h.html#ad20a808b6b88bd966718e7878cb3f588">ccnxName_Release</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>A valid instance of PARCURI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a <code>CCNxName</code> instance initialised from the given URI. </dd>
<dd>
NULL An error occured parsing the URI, or the URI contained an invalid specification.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCURI *uri = parcURI_Parse(&quot;lci:/parc/csl/media/h2162&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(uri);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcURI_Release(&amp;uri);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="adc1d43f5a4dd027883e1ae7ff8df0720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ccnxName_GetNthSegmentNumber </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nthNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Nth segment number of the given <code>CCNxName</code> </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to a valid <code>CCNxName</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthNumber</td><td>The nth segment number in the given name, or SIZE_MAX</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a140e79eacfe8e9e2d0c7d40b16004f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxNameSegment* ccnxName_GetSegment </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the <a class="el" href="">CCNxNameSegment</a> instance for the specified <code>CCNxName</code> at the given index. </p>
<p>The index must be greater than or equal to zero and less than <a class="el" href="ccnx___name_8h.html#aa072270e38a5b382d28deb4a6afa7de5">ccnxName_GetSegmentCount</a>().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The target <code>CCNxName</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index into the <code>name</code> from which to retrieve the <code>CCNxNameSegment</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code>CCNxNameSegment</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/things/b00se&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segment2 = ccnxName_GetSegment(name, 2);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa072270e38a5b382d28deb4a6afa7de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccnxName_GetSegmentCount </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <code>CCNxNameSegments</code> in the specified <code>CCNxName</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to an instance of <code>CCNxName</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of name segments in <code>name</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/things/b00se&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    size_t segmentCount = ccnxName_GetSegmentCount(name);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    printf(&quot;Number of segments: %d\n&quot;, segmentCount);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9abdecee360a758d01b45ae67d59d07a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ccnxName_GetSegmentNumber </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt;#One Line Description#&gt; </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in::&gt;</td><td>| &lt;#out#&gt; | &lt;#in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac7c9f73c5e61c32880e9e01ef60a9ea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCHashCode ccnxName_HashCode </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a hashcode for the given <code>CCNxName</code>. </p>
<p>Whenever <code>HashCode()</code> is invoked on the same object more than once within the same execution environment, the HashCode function must consistently return the same integer, provided no information used in Equals() comparisons on the same object is modified.</p>
<p>This integer need not remain consistent from one execution of an application to another execution of the same application.</p>
<p>If two objects are equal according to the Equals() function, then calling the hashCode method on each of the two objects must produce the same integer result.</p>
<p>It is not required that if two objects are unequal according to the Equals() function, then calling the Equals() method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of some data structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>[in] A pointer to an instance of <code>CCNxName</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint32_t hash code.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/ccn/things/r00&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    uint32_t hashCode = ccnx_LeftMostHashCode(name);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aaabd6857a3c879d20a03781362be85fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxName_IsValid </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an instance of <code>CCNxName</code> is valid. </p>
<p>Valid means the internal state of the type is consistent with its required current or future behaviour. This may include the validation of internal instances of types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to a <code>CCNxName</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the instance is valid. </dd>
<dd>
false if the instance is not valid.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/ccn/things/p1e&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    if (ccnxName_IsValid(name) == true) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aecfa6b4f4d2d94278e005effa536453b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCHashCode ccnxName_LeftMostHashCode </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a hash of the leftmost <code>count</code> <a class="el" href="">CCNxNameSegment</a>s in a <code>CCNxName</code>. </p>
<p>Seelink ccnxName_HashCode} for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to a <code>CCNxName</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number, starting from the left, of path segments to use to compute the hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint32_t hash code.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/ccn/things/r00&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    uint32_t hashCode = ccnx_LeftMostHashCode(name, 2);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad20a808b6b88bd966718e7878cb3f588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxName_Release </td>
          <td>(</td>
          <td class="paramtype">CCNxName **&#160;</td>
          <td class="paramname"><em>nameP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously acquired reference to the specified instance, decrementing the reference count for the instance. </p>
<p>The pointer to the instance is set to NULL as a side-effect of this function.</p>
<p>If the invocation causes the last reference to the instance to be released, the instance is deallocated and the instance's implementation will perform additional cleanup and release other privately held references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nameP</td><td>A pointer to a pointer to the instance to release.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_Create(...);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_8h.html#ac20a8297b9a2c04b429010005ed1ff39">ccnxName_Acquire</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad866c2890b8ea020d1fe3213a803d8e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxName_StartsWith </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a <code>CCNxName</code> is starts with another. </p>
<p>Each <a class="el" href="">CCNxNameSegment</a> in <code>prefix</code> is tested against the corresponding <code>CCNxNameSegment</code> in <code>name</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to a <code>CCNxName</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A pointer to a <code>CCNxName</code> instance to be tested as a prefix of <code>name</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If the given <code>name</code> starts with <code>prefix</code>. </dd>
<dd>
<code>false</code> If the given <code>name</code> does not start with <code>prefix</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/radiation/17&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxName *prefix = ccnxName_CreateFromCString(&quot;lci:/parc/csl&quot;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (ccnxName_StartsWith(name, prefix)) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;       ...</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxName_Release(&amp;prefix);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4dac03639080c1d5d82c6e492d8ea5a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ccnxName_ToString </td>
          <td>(</td>
          <td class="paramtype">const CCNxName *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a null-terminated string representation of the specified instance. </p>
<p>The non-null result must be freed by the caller via <a class="el" href="">parcMemory_Deallocate</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A pointer to the <code>CCNxName</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Cannot allocate memory. </dd>
<dd>
non-NULL A pointer to an allocated, null-terminated C string that must be deallocated via <code>parcMemory_Deallocate()</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *instance = ccnxName_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    char *string = ccnxName_ToString(instance);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    if (string != NULL) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        printf(&quot;Hello: %s\n&quot;, string);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        parcMemory_Deallocate(string);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    } else {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        printf(&quot;Cannot allocate memory\n&quot;);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    ccnxName_Release(&amp;instance);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_8h.html#a02c53396325316a6f917d6269491d750">ccnxName_BuildString</a> </dd>
<dd>
<a class="el" href="ccnx___name_8h.html#a74036b551c2f50d8a3570bcb136b9a46">ccnxName_Display</a> </dd>
<dd>
<a class="el" href="">parcMemory_Deallocate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a813f50e30be9bf49890431fb0ecc8c8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxName* ccnxName_Trim </td>
          <td>(</td>
          <td class="paramtype">CCNxName *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim <code>numberToRemove</code> segments from the end of the specified <code>CCNxName</code>. </p>
<p>If <code>numberToRemove</code> is greater than the number of segments in the name, all segments are removed. If <code>numberToRemove</code> is 0, nothing happens. The name segments are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">name</td><td>A pointer to a <code>CCNxName</code> instance to trim. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberToRemove</td><td>The number of rightmost segments to remove from the name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>name</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/ccn/things/b00se&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    name = ccnxName_Trim(name, 2);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright  2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Mon Aug 29 2016 12:44:52
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084575; 
var sc_invisible=0;
var sc_security="bed914f8"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" src="http://c.statcounter.com/11084575/0/bed914f8/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>

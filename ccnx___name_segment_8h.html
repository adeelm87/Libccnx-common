<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>CCNx Common Library: /Users/gscott/Documents/workspace/CCNx_Distillery-Gatekeeper/CCNx_Distillery/src/Libccnx-common/ccnx/common/ccnx_NameSegment.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">CCNx Common Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_16fe5a6cb4619b62438c1360066364fb.html">Libccnx-common</a></li><li class="navelem"><a class="el" href="dir_ca999156402b63f07c663b5e9508e272.html">ccnx</a></li><li class="navelem"><a class="el" href="dir_0ce23f429e33a65a4627580fe4574273.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ccnx_NameSegment.h File Reference<div class="ingroups"><a class="el" href="group___naming.html">CCN Naming</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A path segment of a CCNx Name.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A path segment of a CCNx Name. </p>
<p>An RFC3986 compliant implementation of URI segments, where each path segment carries a label. See <a class="el" href="">CCNxName</a> for more information.</p>
<dl class="section author"><dt>Author</dt><dd>Glenn Scott, Alan Walendowski, Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2013-2015, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;parc/algol/parc_BufferComposer.h&gt;</code><br />
<code>#include &lt;parc/algol/parc_Buffer.h&gt;</code><br />
<code>#include &lt;<a class="el" href="ccnx___name_label_8h_source.html">ccnx/common/ccnx_NameLabel.h</a>&gt;</code><br />
<code>#include &lt;parc/algol/parc_URI.h&gt;</code><br />
</div>
<p><a href="ccnx___name_segment_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a31d9063b0a1d0545304805b8224a10f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31d9063b0a1d0545304805b8224a10f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ccnxNameSegment_OptionalAssertValid</b>(_instance_)&#160;&#160;&#160;<a class="el" href="ccnx___name_segment_8h.html#af33e319a9c054b27a9ad59eadf5fa885">ccnxNameSegment_AssertValid</a>(_instance_)</td></tr>
<tr class="separator:a31d9063b0a1d0545304805b8224a10f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3a1ee2516aea54ef36f3dcd202923224"><td class="memItemLeft" align="right" valign="top">CCNxNameSegment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a3a1ee2516aea54ef36f3dcd202923224">ccnxNameSegment_CreateTypeValue</a> (<a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a> type, const PARCBuffer *value)</td></tr>
<tr class="memdesc:a3a1ee2516aea54ef36f3dcd202923224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CCNxNameSegment instance initialised with the given type and value.  <a href="#a3a1ee2516aea54ef36f3dcd202923224">More...</a><br /></td></tr>
<tr class="separator:a3a1ee2516aea54ef36f3dcd202923224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdb46dcb1d7f533d9f726e45b846146"><td class="memItemLeft" align="right" valign="top">CCNxNameSegment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#adfdb46dcb1d7f533d9f726e45b846146">ccnxNameSegment_CreateTypeValueArray</a> (<a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a> type, size_t length, const char array[length])</td></tr>
<tr class="memdesc:adfdb46dcb1d7f533d9f726e45b846146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CCNxNameSegment instance initialised with the given type and value taken from the given array of bytes.  <a href="#adfdb46dcb1d7f533d9f726e45b846146">More...</a><br /></td></tr>
<tr class="separator:adfdb46dcb1d7f533d9f726e45b846146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a666a9c7f5cd9b3f67d7b5e05445e9a"><td class="memItemLeft" align="right" valign="top">CCNxNameSegment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a4a666a9c7f5cd9b3f67d7b5e05445e9a">ccnxNameSegment_ParseURISegment</a> (const PARCURISegment *uriSegment)</td></tr>
<tr class="memdesc:a4a666a9c7f5cd9b3f67d7b5e05445e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>CCNxNameSegment</code> from a <a class="el" href="">PARCURISegment</a> consisting of type specification and value.  <a href="#a4a666a9c7f5cd9b3f67d7b5e05445e9a">More...</a><br /></td></tr>
<tr class="separator:a4a666a9c7f5cd9b3f67d7b5e05445e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe40e8ff443c64abf1f63824090fb9f3"><td class="memItemLeft" align="right" valign="top">CCNxNameSegment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#abe40e8ff443c64abf1f63824090fb9f3">ccnxNameSegment_Copy</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:abe40e8ff443c64abf1f63824090fb9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <code>CCNxNameSegment</code> by copying the given <code>CCNxNameSegment</code>.  <a href="#abe40e8ff443c64abf1f63824090fb9f3">More...</a><br /></td></tr>
<tr class="separator:abe40e8ff443c64abf1f63824090fb9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c81e4869b734969cd34df27d9be769"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a96c81e4869b734969cd34df27d9be769">ccnxNameSegment_Equals</a> (const CCNxNameSegment *segmentA, const CCNxNameSegment *segmentB)</td></tr>
<tr class="memdesc:a96c81e4869b734969cd34df27d9be769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <code>CCNxNameSegment</code> instances are equal.  <a href="#a96c81e4869b734969cd34df27d9be769">More...</a><br /></td></tr>
<tr class="separator:a96c81e4869b734969cd34df27d9be769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be38ab277368578b01b6c54984b527"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a04be38ab277368578b01b6c54984b527">ccnxNameSegment_Compare</a> (const CCNxNameSegment *segmentA, const CCNxNameSegment *segmentB)</td></tr>
<tr class="memdesc:a04be38ab277368578b01b6c54984b527"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signum function comparing two <code>CCNxNameSegment</code> instances.  <a href="#a04be38ab277368578b01b6c54984b527">More...</a><br /></td></tr>
<tr class="separator:a04be38ab277368578b01b6c54984b527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a490be666d1ee4c2bc4963f6dbada1c"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a6a490be666d1ee4c2bc4963f6dbada1c">ccnxNameSegment_GetValue</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:a6a490be666d1ee4c2bc4963f6dbada1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying PARCBuffer storing the value of the given <code>CCNxNameSegment</code>.  <a href="#a6a490be666d1ee4c2bc4963f6dbada1c">More...</a><br /></td></tr>
<tr class="separator:a6a490be666d1ee4c2bc4963f6dbada1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63733fc9fb8332d1e2bf39dee6f6d0a"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#aa63733fc9fb8332d1e2bf39dee6f6d0a">ccnxNameSegment_GetParameter</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:aa63733fc9fb8332d1e2bf39dee6f6d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying PARCBuffer storing the parameter of the given <code>CCNxNameSegment</code>.  <a href="#aa63733fc9fb8332d1e2bf39dee6f6d0a">More...</a><br /></td></tr>
<tr class="separator:aa63733fc9fb8332d1e2bf39dee6f6d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4443d618d9fa947dd22f3e3d2bda1a7b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a4443d618d9fa947dd22f3e3d2bda1a7b">ccnxNameSegment_ToString</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:a4443d618d9fa947dd22f3e3d2bda1a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a nul-terminated C string representation of the given <code>CCNxNameSegment</code>.  <a href="#a4443d618d9fa947dd22f3e3d2bda1a7b">More...</a><br /></td></tr>
<tr class="separator:a4443d618d9fa947dd22f3e3d2bda1a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeb6f4a75391ca1c8a8f7e92341d7b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a0aeb6f4a75391ca1c8a8f7e92341d7b6">ccnxNameSegment_Display</a> (const CCNxNameSegment *segment, int indentation)</td></tr>
<tr class="memdesc:a0aeb6f4a75391ca1c8a8f7e92341d7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a human readable representation of the given <code>CCNxNameSegment</code>.  <a href="#a0aeb6f4a75391ca1c8a8f7e92341d7b6">More...</a><br /></td></tr>
<tr class="separator:a0aeb6f4a75391ca1c8a8f7e92341d7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb74dc9adf8722f078113ed08665176c"><td class="memItemLeft" align="right" valign="top">PARCBufferComposer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#abb74dc9adf8722f078113ed08665176c">ccnxNameSegment_BuildString</a> (const CCNxNameSegment *segment, PARCBufferComposer *composer)</td></tr>
<tr class="memdesc:abb74dc9adf8722f078113ed08665176c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a printable-character representation of the specified instance to the given <a class="el" href="">PARCBufferComposer</a>.  <a href="#abb74dc9adf8722f078113ed08665176c">More...</a><br /></td></tr>
<tr class="separator:abb74dc9adf8722f078113ed08665176c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2686c452686eec6bcb4f176c507cba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a7e2686c452686eec6bcb4f176c507cba">ccnxNameSegment_Length</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:a7e2686c452686eec6bcb4f176c507cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the specified <code>CCNxNameSegment</code>, in bytes.  <a href="#a7e2686c452686eec6bcb4f176c507cba">More...</a><br /></td></tr>
<tr class="separator:a7e2686c452686eec6bcb4f176c507cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6773463852632cc7af75e43fe12df3c0"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a6773463852632cc7af75e43fe12df3c0">ccnxNameSegment_GetLabel</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:a6773463852632cc7af75e43fe12df3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the label of the given <code>CCNxNameSegment</code>.  <a href="#a6773463852632cc7af75e43fe12df3c0">More...</a><br /></td></tr>
<tr class="separator:a6773463852632cc7af75e43fe12df3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f16c8f3e7ddfed898986232f24b41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#aab9f16c8f3e7ddfed898986232f24b41">ccnxNameSegment_GetType</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:aab9f16c8f3e7ddfed898986232f24b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a> of the given <code>CCNxNameSegment</code>.  <a href="#aab9f16c8f3e7ddfed898986232f24b41">More...</a><br /></td></tr>
<tr class="separator:aab9f16c8f3e7ddfed898986232f24b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8633da30ce63b8360bc3777be66b3626"><td class="memItemLeft" align="right" valign="top">PARCHashCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a8633da30ce63b8360bc3777be66b3626">ccnxNameSegment_HashCode</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:a8633da30ce63b8360bc3777be66b3626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hashcode for the given <code>CCNxNameSegment</code>.  <a href="#a8633da30ce63b8360bc3777be66b3626">More...</a><br /></td></tr>
<tr class="separator:a8633da30ce63b8360bc3777be66b3626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6815a73693e89d2dd10b5d1f91f70bd7"><td class="memItemLeft" align="right" valign="top">CCNxNameSegment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a6815a73693e89d2dd10b5d1f91f70bd7">ccnxNameSegment_Acquire</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:a6815a73693e89d2dd10b5d1f91f70bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of references to a <code>CCNxNameSegment</code>.  <a href="#a6815a73693e89d2dd10b5d1f91f70bd7">More...</a><br /></td></tr>
<tr class="separator:a6815a73693e89d2dd10b5d1f91f70bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766ad5480119d37a48d9bb010048af62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#a766ad5480119d37a48d9bb010048af62">ccnxNameSegment_Release</a> (CCNxNameSegment **segmentP)</td></tr>
<tr class="memdesc:a766ad5480119d37a48d9bb010048af62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired reference to the specified instance, decrementing the reference count for the instance.  <a href="#a766ad5480119d37a48d9bb010048af62">More...</a><br /></td></tr>
<tr class="separator:a766ad5480119d37a48d9bb010048af62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33e319a9c054b27a9ad59eadf5fa885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#af33e319a9c054b27a9ad59eadf5fa885">ccnxNameSegment_AssertValid</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:af33e319a9c054b27a9ad59eadf5fa885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that an instance of <code>CCNxNameSegment</code> is valid.  <a href="#af33e319a9c054b27a9ad59eadf5fa885">More...</a><br /></td></tr>
<tr class="separator:af33e319a9c054b27a9ad59eadf5fa885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70db102531593f2be6b0e7470f8378b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx___name_segment_8h.html#ae70db102531593f2be6b0e7470f8378b">ccnxNameSegment_IsValid</a> (const CCNxNameSegment *segment)</td></tr>
<tr class="memdesc:ae70db102531593f2be6b0e7470f8378b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an instance of <code>CCNxNameSegment</code> is valid.  <a href="#ae70db102531593f2be6b0e7470f8378b">More...</a><br /></td></tr>
<tr class="separator:ae70db102531593f2be6b0e7470f8378b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6815a73693e89d2dd10b5d1f91f70bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxNameSegment* ccnxNameSegment_Acquire </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of references to a <code>CCNxNameSegment</code>. </p>
<p>Note that a new <code>CCNxNameSegment</code> is not created, only that the given <code>CCNxNameSegment</code> reference count is incremented. Discard the reference by invoking <a class="el" href="ccnx___name_segment_8h.html#a766ad5480119d37a48d9bb010048af62">ccnxNameSegment_Release</a>().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to the original instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the input parameter <code>instance</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxNameSegment *segment = ccnxNameSegment_Acquire(instance);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxNameSegment_Release(&amp;segment);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_segment_8h.html#a766ad5480119d37a48d9bb010048af62" title="Release a previously acquired reference to the specified instance, decrementing the reference count f...">ccnxNameSegment_Release</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af33e319a9c054b27a9ad59eadf5fa885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxNameSegment_AssertValid </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert that an instance of <code>CCNxNameSegment</code> is valid. </p>
<p>If the instance is not valid, terminate via <a class="el" href="">trapIllegalValue</a></p>
<p>Valid means the internal state of the type is consistent with its required current or future behaviour. This may include the validation of internal instances of types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to the instance to check.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxNameSegment_AssertValid(segment);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abb74dc9adf8722f078113ed08665176c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBufferComposer* ccnxNameSegment_BuildString </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCBufferComposer *&#160;</td>
          <td class="paramname"><em>composer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a printable-character representation of the specified instance to the given <a class="el" href="">PARCBufferComposer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to the <code>CCNxNameSegment</code> instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">composer</td><td>A pointer to the <code>PARCBufferComposer</code> instance onto which to append our printable representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Cannot allocate memory. </dd>
<dd>
non-NULL The <code>composer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBufferComposer *result = parcBufferComposer_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxNameSegment_BuildString(instance, result);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    char *string = parcBuffer_ToString(parcBufferComposer_ProduceBuffer(result));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    printf(&quot;Hello: %s\n&quot;, string);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcMemory_Deallocate(string);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBufferComposer_Release(&amp;result);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>PARCBufferComposer </dd></dl>

</div>
</div>
<a class="anchor" id="a04be38ab277368578b01b6c54984b527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccnxNameSegment_Compare </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segmentA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segmentB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signum function comparing two <code>CCNxNameSegment</code> instances. </p>
<p>Used to determine the ordering relationship of two <code>CCNxNameSegment</code> instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segmentA</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segmentB</td><td>A pointer to a <code>CCNxNameSegment</code> instance to be compared to <code>segmentA</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if <code>segmentA</code> and <code>segmentB</code> are equivalent </dd>
<dd>
&lt; 0 if <code>segmentA</code> &lt; <code>segmentB</code> </dd>
<dd>
&gt; 0 if <code>segmentA</code> &gt; <code>segmentB</code></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *valueA = parcBuffer_WrapCString(&quot;apple&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segmentA = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_NAME, valueA);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCBuffer *valueB = parcBuffer_WrapCString(&quot;banana&quot;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    CCNxNameSegment *segmentB = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_NAME, valueB);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    int signum = ccnxNameSegment_Compare(segmentA, segmentB);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxNameSegment_Release(&amp;segmentA);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    parcBuffer_Release(&amp;bufA);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    ccnxNameSegment_Release(&amp;segmentB);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    parcBuffer_Release(&amp;bufB);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abe40e8ff443c64abf1f63824090fb9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxNameSegment* ccnxNameSegment_Copy </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <code>CCNxNameSegment</code> by copying the given <code>CCNxNameSegment</code>. </p>
<p>This is a deep copy, and the created instance must eventually be released by calling <a class="el" href="ccnx___name_segment_8h.html#a766ad5480119d37a48d9bb010048af62">ccnxNameSegment_Release</a>().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A <code>CCNxNameSegment</code> pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated <code>CCNxNameSegment</code> which must eventually be released by calling <a class="el" href="ccnx___name_segment_8h.html#a766ad5480119d37a48d9bb010048af62">ccnxNameSegment_Release</a>().</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *value = parcBuffer_WrapCString(&quot;hello&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segment = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_NAME, value);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxNameSegment *copy = ccnxNameSegment_Copy(segment);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxNameSegment_Release(&amp;segment);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxNameSegment_Copy(&amp;copy);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_Release(&amp;value);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3a1ee2516aea54ef36f3dcd202923224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxNameSegment* ccnxNameSegment_CreateTypeValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CCNxNameSegment instance initialised with the given type and value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A valid CCNxNameLabelType </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A valid PARCBuffer containing the value of the name segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a valid CCNxNameSegment instance. </dd>
<dd>
NULL An error occurred.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *value = parcBuffer_WrapCString(&quot;value&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxNameSegment *expected = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_NAME, value);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;value);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="adfdb46dcb1d7f533d9f726e45b846146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxNameSegment* ccnxNameSegment_CreateTypeValueArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>array</em>[length]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CCNxNameSegment instance initialised with the given type and value taken from the given array of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A valid CCNxNameLabelType </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes in <code>array</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>A pointer to a buffer containing the bytes for the value of the name segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a valid CCNxNameSegment instance. </dd>
<dd>
NULL An error occurred.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxNameSegment *expected = ccnxNameSegment_CreateTypeValueArray(CCNxNameLabelType_NAME, 5, &quot;value&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0aeb6f4a75391ca1c8a8f7e92341d7b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxNameSegment_Display </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a human readable representation of the given <code>CCNxNameSegment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to the instance to display. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indentation</td><td>The level of indentation to use to pretty-print the output.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/radiation/212&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segment = ccnxName_GetSegment(name, 3);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ccnxNameSegment_Display(segment, 0);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a96c81e4869b734969cd34df27d9be769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxNameSegment_Equals </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segmentA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segmentB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <code>CCNxNameSegment</code> instances are equal. </p>
<p>The following equivalence relations on non-null <code>CCNxNameSegment</code> instances are maintained:</p>
<ul>
<li>It is reflexive: for any non-null reference value x, <code>ccnxNameSegment_Equal(x, x)</code> must return true.</li>
<li>It is symmetric: for any non-null reference values x and y, <code>ccnxNameSegment_Equal(x, y)</code> must return true if and only if <code>ccnxNameSegment_Equal(y x)</code> returns true.</li>
<li>It is transitive: for any non-null reference values x, y, and z, if <code>ccnxNameSegment_Equal(x, y)</code> returns true and <code>ccnxNameSegment_Equal(y, z)</code> returns true, then <code>ccnxNameSegment_Equal(x, z)</code> must return true.</li>
<li>It is consistent: for any non-null reference values x and y, multiple invocations of <code>ccnxNameSegment_Equal(x, y)</code> consistently return true or consistently return false.</li>
<li>For any non-null reference value x, <code>ccnxNameSegment_Equal(x, NULL)</code> must return false.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segmentA</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segmentB</td><td>A pointer to a <code>CCNxNameSegment</code> instance to be compared to <code>segmentA</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given <code>CCNxNameSegment</code> instances are equal.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    char *lciSegment = CCNxNameLabelType_Label_Chunk &quot;=&quot; &quot;123&quot;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARC_URISegment *uriSegment = parcURISegment_Parse(lciSegment, NULL);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxNameSegment *segmentA = ccnxNameSegment_ParseURISegment(uriSegment);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    PARCBuffer *buf = parcBuffer_WrapCString(&quot;123&quot;);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    CCNxNameSegment *segmentB = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_CHUNK, buf);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    if (ccnxNameSegment_Equals(expected, actual)) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;         // true</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;     } else {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;         // false</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;     }</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    ccnxNameSegment_Release(&amp;segmentA);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    ccnxNameSegment_Release(&amp;segmentB);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    parcURISegment_Release(&amp;uriSegment);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    parcBuffer_Release(&amp;buf);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6773463852632cc7af75e43fe12df3c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* ccnxNameSegment_GetLabel </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the label of the given <code>CCNxNameSegment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a PARCBuffer instance containing the label. </dd>
<dd>
NULL The CCNxNameSegment instance does not have a label.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buf = parcBuffer_WrapCString(&quot;apple&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segment = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_NAME, buf);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxNameLabelType type = ccnxNameSegment_GetType(segment);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxNameSegment_Release(&amp;segment);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buf);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704" title="An enumeration of possible CCNxName types. ">CCNxNameLabelType</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="aa63733fc9fb8332d1e2bf39dee6f6d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* ccnxNameSegment_GetParameter </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the underlying PARCBuffer storing the parameter of the given <code>CCNxNameSegment</code>. </p>
<p>A new reference to the instance is not created. If the caller requires a reference to live beyond the lifetime of the <code>CCNxNameSegment</code> it must acquire a reference via <a class="el" href="">parcBuffer_Acquire</a>.</p>
<p>Any modifications to the buffer's position, limit or mark will affect subsequent use of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL The given <code>CCNxNameSegment</code> does not specify a parameter value. </dd>
<dd>
non-NULL A pointer to the underlying <code>PARCBuffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxNameSegment *segment = ccnxNameSegment_ParseURISegment(&quot;label:param=value&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCBuffer *parameter = ccnxNameSegment_GetParameter(segment);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxNameSegment_Release(&amp;segment);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_segment_8h.html#a7e2686c452686eec6bcb4f176c507cba">ccnxNameSegment_Length</a>() </dd></dl>

</div>
</div>
<a class="anchor" id="aab9f16c8f3e7ddfed898986232f24b41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a> ccnxNameSegment_GetType </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704">CCNxNameLabelType</a> of the given <code>CCNxNameSegment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>CCNxNameLabelType</code> of the specified <code>CCNxNameSegment</code> instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buf = parcBuffer_WrapCString(&quot;apple&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segment = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_NAME, buf);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxNameLabelType type = ccnxNameSegment_GetType(segment);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxNameSegment_Release(&amp;segment);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buf);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="ccnx___name_label_8h.html#a4732eb5288ec48059453c44dde3d6704" title="An enumeration of possible CCNxName types. ">CCNxNameLabelType</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a490be666d1ee4c2bc4963f6dbada1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* ccnxNameSegment_GetValue </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the underlying PARCBuffer storing the value of the given <code>CCNxNameSegment</code>. </p>
<p>A new reference to the instance is not created. If the caller requires a reference to live beyond the lifetime of the <code>CCNxNameSegment</code> it must acquire a reference via <a class="el" href="">parcBuffer_Acquire</a>.</p>
<p>Any modifications to the buffer's position, limit or mark will affect subsequent use of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the underlying <a class="el" href="">Example:  { PARC_URISegment *uriSegment = parcURISegment_Parse("label:param=value");  CCNxNameSegment *actual = ccnxNameSegment_ParseURISegment(uriSegment);  PARCBuffer *value = ccnxNameSegment_GetValue(actual);  ccnxNameSegment_Release(&amp;actual); parcURISegment_Release(&amp;uriSegment); }    ccnxNameSegment_Length}() </a></dd></dl>

</div>
</div>
<a class="anchor" id="a8633da30ce63b8360bc3777be66b3626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCHashCode ccnxNameSegment_HashCode </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a hashcode for the given <code>CCNxNameSegment</code>. </p>
<p>Whenever <code>HashCode()</code> is invoked on the same instance more than once within the same execution environment, the HashCode function must consistently return the same value, provided no information used in its corresponding <code>Equals()</code> comparisons on the same instance is modified.</p>
<p>This value need not remain consistent from one execution of an application to another execution of the same application.</p>
<p>If two instances are equal according to the <code>Equals()</code> function, then calling the <code>HashCode</code> function on each of the two objects must produce the same integer result.</p>
<p>It is not required that if two instances are unequal according to the <code>Equals()</code> function, then calling the HashCode() method on each of the two instances must produce distinct integer results. However, the programmer should be aware that producing distinct results for unequal instances may improve the performance of some data structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned 32-bit integer hash code value.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *bufA =parcBuffer_WrapCString(&quot;Test&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxNameSegment *segmentA = ccnxNameSegment_CreateTypeValue(CCNxNameLabelType_NAME, bufA);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    uint32_t hashCode = ccnxNameSegment_HashCode(segmentA);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ccnxNameSegment_Release(&amp;segmentA);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_Release(&amp;bufA);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code>parcHash32Bits_Hash</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae70db102531593f2be6b0e7470f8378b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxNameSegment_IsValid </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an instance of <code>CCNxNameSegment</code> is valid. </p>
<p>Valid means the internal state of the type is consistent with its required current or future behaviour. This may include the validation of internal instances of referenced objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to the instance to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The instance is valid. </dd>
<dd>
false The instance is not valid.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ccnxNameSegment_IsValid(segment);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7e2686c452686eec6bcb4f176c507cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccnxNameSegment_Length </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of the specified <code>CCNxNameSegment</code>, in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A pointer to a <code>CCNxNameSegment</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes for the value of the given <code>CCNxNameSegment</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/humidity/12&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segment = ccnxName_GetSegment(name, 3);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    int length = ccnxNameSegment_Length(segment);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4a666a9c7f5cd9b3f67d7b5e05445e9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNxNameSegment* ccnxNameSegment_ParseURISegment </td>
          <td>(</td>
          <td class="paramtype">const PARCURISegment *&#160;</td>
          <td class="paramname"><em>uriSegment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a <code>CCNxNameSegment</code> from a <a class="el" href="">PARCURISegment</a> consisting of type specification and value. </p>
<p>The name must be in conformance with <code>draft-mosko-icnrg-ccnxlabeledcontent-00</code></p>
<p>Names that use mnemonic values for labels, must conform to thier respective specifications. See <code>draft-scott-icnrg-ccnxnameregistry-00</code> for a list of assigned names and type values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uriSegment</td><td>A pointer to a valid <code>PARCURISegment</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to an allocated <code>CCNxNameSegment</code> which must eventually be released by calling <a class="el" href="ccnx___name_segment_8h.html#a766ad5480119d37a48d9bb010048af62">ccnxNameSegment_Release</a>(). </dd>
<dd>
NULL An error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="ccnx___name_segment_8h.html#a766ad5480119d37a48d9bb010048af62" title="Release a previously acquired reference to the specified instance, decrementing the reference count f...">ccnxNameSegment_Release()</a></code></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    char *lciSegment = CCNxNameLabel_Name &quot;=&quot; &quot;abcde&quot;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARC_URISegment *uriSegment = parcURISegment_Parse(lciSegment, NULL);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    CCNxNameSegment *actual = ccnxNameSegment_ParseURISegment(uriSegment);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    CCNxNameLabelType type = ccnxNameSegment_GetType(actual);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    assertTrue(CCNxNameLabelType_NAME == type, &quot;Expected %04x, actual %04x&quot;, 0x20, type);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ccnxNameSegment_Release(&amp;actual);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    parcURISegment_Release(&amp;uriSegment);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a766ad5480119d37a48d9bb010048af62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccnxNameSegment_Release </td>
          <td>(</td>
          <td class="paramtype">CCNxNameSegment **&#160;</td>
          <td class="paramname"><em>segmentP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously acquired reference to the specified instance, decrementing the reference count for the instance. </p>
<p>The pointer to the instance is set to NULL as a side-effect of this function.</p>
<p>If the invocation causes the last reference to the instance to be released, the instance is deallocated and the instance's implementation will perform additional cleanup and release other privately held references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">segmentP</td><td>A pointer to a pointer to the instance to release.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CCNxNameSegment *segment = ccnxNameSegment_Acquire(instance);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ccnxNameSegment_Release(&amp;segment);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ccnx___name_segment_8h.html#a6815a73693e89d2dd10b5d1f91f70bd7" title="Increase the number of references to a CCNxNameSegment. ">ccnxNameSegment_Acquire</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4443d618d9fa947dd22f3e3d2bda1a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ccnxNameSegment_ToString </td>
          <td>(</td>
          <td class="paramtype">const CCNxNameSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a nul-terminated C string representation of the given <code>CCNxNameSegment</code>. </p>
<p>A string representation, such as "1=foo".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>A CCNxNameSegment pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated null-terminated byte array that must be deallocated by <code>{@link parcMemory_Deallocate}()</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    CCNxName *name = ccnxName_CreateFromCString(&quot;lci:/parc/csl/sensors/radiation/212&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CCNxNameSegment *segment = ccnxName_GetSegment(name, 3);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    char *string = ccnxNameSegment_ToString(segment);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    printf(&quot;Hello: %s\n&quot;, string);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcMemory_Deallocate(string);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ccnxName_Release(&amp;name);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code>parcMemory_Deallocate</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright  2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Mon Aug 29 2016 12:44:52
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084575; 
var sc_invisible=0;
var sc_security="bed914f8"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" src="http://c.statcounter.com/11084575/0/bed914f8/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>CCNx Common Library: /Users/gscott/Documents/workspace/CCNx_Distillery-Gatekeeper/CCNx_Distillery/src/Libccnx-common/ccnx/common/codec/ccnxCodec_TlvUtilities.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">CCNx Common Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_16fe5a6cb4619b62438c1360066364fb.html">Libccnx-common</a></li><li class="navelem"><a class="el" href="dir_ca999156402b63f07c663b5e9508e272.html">ccnx</a></li><li class="navelem"><a class="el" href="dir_0ce23f429e33a65a4627580fe4574273.html">common</a></li><li class="navelem"><a class="el" href="dir_d1ed8e9c4e537cf63813a234e25cada0.html">codec</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ccnxCodec_TlvUtilities.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions common to all the codecs.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions common to all the codecs. </p>
<p>&lt;#Detailed Description#&gt;</p>
<dl class="section author"><dt>Author</dt><dd>Marc Mosko, Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2013-2015, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;ccnx/common/internal/ccnx_TlvDictionary.h&gt;</code><br />
<code>#include &lt;<a class="el" href="ccnx_codec___tlv_encoder_8h_source.html">ccnx/common/codec/ccnxCodec_TlvEncoder.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ccnx_codec___tlv_decoder_8h_source.html">ccnx/common/codec/ccnxCodec_TlvDecoder.h</a>&gt;</code><br />
</div>
<p><a href="ccnx_codec___tlv_utilities_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a35188e57339265054b5296cad148bd98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#a35188e57339265054b5296cad148bd98">ccnxCodecTlvUtilities_DecodeContainer</a> (CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, bool(*typeDecoder)(CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length))</td></tr>
<tr class="memdesc:a35188e57339265054b5296cad148bd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a list of TLV entries.  <a href="#a35188e57339265054b5296cad148bd98">More...</a><br /></td></tr>
<tr class="separator:a35188e57339265054b5296cad148bd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed027ea147ddd0a39e1f06d7f9f0aba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#aed027ea147ddd0a39e1f06d7f9f0aba5">ccnxCodecTlvUtilities_DecodeSubcontainer</a> (CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t key, uint16_t length, bool(*subcontainerDecoder)(CCNxCodecTlvDecoder *, CCNxTlvDictionary *))</td></tr>
<tr class="memdesc:aed027ea147ddd0a39e1f06d7f9f0aba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an inner decoder of for decoding a subcontainer.  <a href="#aed027ea147ddd0a39e1f06d7f9f0aba5">More...</a><br /></td></tr>
<tr class="separator:aed027ea147ddd0a39e1f06d7f9f0aba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aa106085c028d45bc1b11ab3576528"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#a44aa106085c028d45bc1b11ab3576528">ccnxCodecTlvUtilities_PutAsBuffer</a> (CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length, int dictionaryKey)</td></tr>
<tr class="memdesc:a44aa106085c028d45bc1b11ab3576528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes 'length' bytes from the decoder and puts it in the dictionary.  <a href="#a44aa106085c028d45bc1b11ab3576528">More...</a><br /></td></tr>
<tr class="separator:a44aa106085c028d45bc1b11ab3576528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ee27e1b65335edf431788274142de3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#a83ee27e1b65335edf431788274142de3">ccnxCodecTlvUtilities_PutAsHash</a> (CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length, int dictionaryKey)</td></tr>
<tr class="memdesc:a83ee27e1b65335edf431788274142de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a <code>PARCCryptoHash</code> value of 'length' bytes from the decoder and puts it in the dictionary.  <a href="#a83ee27e1b65335edf431788274142de3">More...</a><br /></td></tr>
<tr class="separator:a83ee27e1b65335edf431788274142de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520ee43a507b2b55a6db6de133c79ef3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#a520ee43a507b2b55a6db6de133c79ef3">ccnxCodecTlvUtilities_PutAsInteger</a> (CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length, int dictionaryKey)</td></tr>
<tr class="memdesc:a520ee43a507b2b55a6db6de133c79ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the value as a VarInt and saves it as an Integer in the Dictionary.  <a href="#a520ee43a507b2b55a6db6de133c79ef3">More...</a><br /></td></tr>
<tr class="separator:a520ee43a507b2b55a6db6de133c79ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8d01fcaa2d12809aa1efe9e80ca45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#a7ad8d01fcaa2d12809aa1efe9e80ca45">ccnxCodecTlvUtilities_PutAsName</a> (CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length, int arrayKey)</td></tr>
<tr class="memdesc:a7ad8d01fcaa2d12809aa1efe9e80ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes 'length' bytes from the decoder and puts it in the dictionary as a CCNxName.  <a href="#a7ad8d01fcaa2d12809aa1efe9e80ca45">More...</a><br /></td></tr>
<tr class="separator:a7ad8d01fcaa2d12809aa1efe9e80ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fed3b6b2e00618c67af3fc5f494716"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#ab7fed3b6b2e00618c67af3fc5f494716">ccnxCodecTlvUtilities_PutAsListBuffer</a> (CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length, int listKey)</td></tr>
<tr class="memdesc:ab7fed3b6b2e00618c67af3fc5f494716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 'length' bytes from the decoder and appends a PARCBuffer to a list in packetDictionary.  <a href="#ab7fed3b6b2e00618c67af3fc5f494716">More...</a><br /></td></tr>
<tr class="separator:ab7fed3b6b2e00618c67af3fc5f494716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b50b6610ca2593dce8d0b0c1fbeb57c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#a9b50b6610ca2593dce8d0b0c1fbeb57c">ccnxCodecTlvUtilities_NestedEncode</a> (CCNxCodecTlvEncoder *outerEncoder, CCNxTlvDictionary *packetDictionary, uint32_t nestedType, ssize_t(*nestedEncoderFunction)(CCNxCodecTlvEncoder *innerEncoder, CCNxTlvDictionary *packetDictionary))</td></tr>
<tr class="memdesc:a9b50b6610ca2593dce8d0b0c1fbeb57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes a nested TLV container (the opposite of ccnxCodecTlvUtilities_DecodeSubcontainer)  <a href="#a9b50b6610ca2593dce8d0b0c1fbeb57c">More...</a><br /></td></tr>
<tr class="separator:a9b50b6610ca2593dce8d0b0c1fbeb57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98edc8aa51f8d11407081460caa7862e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#a98edc8aa51f8d11407081460caa7862e">ccnxCodecTlvUtilities_EncodeCustomList</a> (CCNxCodecTlvEncoder *encoder, CCNxTlvDictionary *packetDictionary, int listKey)</td></tr>
<tr class="memdesc:a98edc8aa51f8d11407081460caa7862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the list 'listKey' from the dictionary and encodes them all as TLV entries.  <a href="#a98edc8aa51f8d11407081460caa7862e">More...</a><br /></td></tr>
<tr class="separator:a98edc8aa51f8d11407081460caa7862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecfc8c47f3951dbeae7c9e903f67cc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnx_codec___tlv_utilities_8h.html#abecfc8c47f3951dbeae7c9e903f67cc3">ccnxCodecTlvUtilities_GetVarInt</a> (PARCBuffer *input, size_t length, uint64_t *output)</td></tr>
<tr class="memdesc:abecfc8c47f3951dbeae7c9e903f67cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the input buffer as a VarInt.  <a href="#abecfc8c47f3951dbeae7c9e903f67cc3">More...</a><br /></td></tr>
<tr class="separator:abecfc8c47f3951dbeae7c9e903f67cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a35188e57339265054b5296cad148bd98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_DecodeContainer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length)&#160;</td>
          <td class="paramname"><em>typeDecoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes a list of TLV entries. </p>
<p>The decoder should point to the first byte of a "type". This function will iterate over all the TLVs and call the user function 'typeDecoder' for each type-length.</p>
<p>It is the responsibility of typeDecoder to advance the decoder by 'length' bytes. It should return false if it does not consume exactly 'length' bytes.</p>
<p>The function will proceed until it can no longer parse a TLV header (4 bytes). If the function consumes all the bytes in the decoder without error, it will return true. If it encounters an error from 'typeDecoder' it will return false at that point. If there is an underflow (i.e. 1, 2, or 3 bytes) left in the decoder at the end it will return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The TLV decoder that should point to the start of the TLV list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>The dictionary to use to store packet fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeDecoder</td><td>the user-supplied function to call for each TLV found in the container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true There were no errors returned by 'typeDecoder' and we consumed the entire decoder buffer </dd>
<dd>
false There was an error or we did not consume the entire decoder buffer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   static bool</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   testTypeDecoder(CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   switch (type) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      case 0x000C: // fallthrough</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      case 0x000D:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;         ccnxCodecTlvDecoder_Advance(decoder, length);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;         return true;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;      default:</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;         return false;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;      }</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   }</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   void foo(void)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;      // A list of 2 TLV containers (types 0x000C and 0x000D)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      uint8_t metadataContainer[] = {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;         0x00, 0x0C, 0x00, 0x01,     // Object Type, length = 1</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;         0x04,                       // LINK</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;         0x00, 0x0D, 0x00,    8,     // Creation Time</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;         0x00, 0x00, 0x01, 0x43,     // 1,388,534,400,000 msec</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;         0x4B, 0x19, 0x84, 0x00,</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;      };</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;      PARCBuffer *buffer = parcBuffer_Wrap(metadataContainer, sizeof(metadataContainer), 0, sizeof(metadataContainer) );</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;      // now decode that snippit</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;      CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;      CCNxTlvDictionary *dictionary = ccnxTlvDictionary_Create(10,10);</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;      bool success = ccnxCodecTlvUtilities_DecodeContainer(decoder, dictionary, testTypeDecoder);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;      ccnxTlvDictionary_Release(&amp;dictionary);</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      ccnxCodecTlvDecoder_Destroy(&amp;decoder);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      assertTrue(success, &quot;The TLV types were known to us&quot;);</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;   }</div></div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Mosko, Marc <a href="#" onclick="location.href='mai'+'lto:'+'Mar'+'c.'+'Mos'+'ko'+'@pa'+'rc'+'.co'+'m'; return false;">Marc.<span style="display: none;">.nosp@m.</span>Mosk<span style="display: none;">.nosp@m.</span>o@par<span style="display: none;">.nosp@m.</span>c.co<span style="display: none;">.nosp@m.</span>m</a> , Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2013-2015, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>

</div>
</div>
<a class="anchor" id="aed027ea147ddd0a39e1f06d7f9f0aba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_DecodeSubcontainer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(CCNxCodecTlvDecoder *, CCNxTlvDictionary *)&#160;</td>
          <td class="paramname"><em>subcontainerDecoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an inner decoder of for decoding a subcontainer. </p>
<p>The decoder should point at the first byte of the "value", which is known to be a subcontainer listing other TLVs. This function will create an inner decoder and then call 'ccnxCodecTlvUtilities_DecodeContainer' with it to decode the inner TLVs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder that points to the fist byte of a list of TLVs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>Where to put the results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>NOT USED </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the subcontainer. The inner decoder will end after this may bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subcontainerDecoder</td><td>The function to pass to 'ccnxCodecTlvUtilities_DecodeContainer' for the inner decoder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true There were no errors and consumed 'length' bytes </dd>
<dd>
false An error or did not consume 'length' bytes</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // The KeyLocator field is known to be a subcontainer containing its own TLV fields.  When we encounter that</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  // TLV type, we parse the &#39;value&#39; of it as a subcontainer</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  //</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  static bool</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  rtaTlvSchemaV0NameAuth_DecodeType(CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     bool success = false;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     switch (type) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;     case CCNxCodecSchemaV0_NameAuthKeys_KeyLocator:</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        success = ccnxCodecTlvUtilities_DecodeSubcontainer(decoder, packetDictionary, type, length, rtaTlvSchemaV0KeyLocator_Decode);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        break;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;     case CCNxCodecSchemaV0_NameAuthKeys_CryptoSuite:</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        success = ccnxCodecTlvUtilities_PutAsBuffer(decoder, packetDictionary, type, length, CCNxCodecSchemaV0TlvDictionary_ContentObjectFastArray_CRYPTO_SUITE);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        break;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;     case CCNxCodecSchemaV0_NameAuthKeys_KeyId:</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        success = ccnxCodecTlvUtilities_PutAsBuffer(decoder, packetDictionary, type, length, CCNxCodecSchemaV0TlvDictionary_ContentObjectFastArray_KEYID);</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        break;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;     default:</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        // if we do not know the TLV type, put it in this container&#39;s unknown list</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        success = ccnxCodecTlvUtilities_PutAsListBuffer(decoder, packetDictionary, type, length, CCNxCodecSchemaV0TlvDictionary_ContentObjectLists_NAMEAUTH_LIST);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        break;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;     }</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;     return success;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a98edc8aa51f8d11407081460caa7862e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ccnxCodecTlvUtilities_EncodeCustomList </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvEncoder *&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>listKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the list 'listKey' from the dictionary and encodes them all as TLV entries. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoder</td><td>The encoder to append to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>The dictionary to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listKey</td><td>The list key to read from packetDictionary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abecfc8c47f3951dbeae7c9e903f67cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_GetVarInt </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the input buffer as a VarInt. </p>
<p>Parses the bytes of the input buffer as a network byte order variable length integer. Between 1 and 'length' bytes will be parses, where 'length' must be from 1 to 8. The buffer will be advanced as the bytes are read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     PARCBuffer *buffer = parcBuffer_Wrap((uint8_t[]) { 0x10, 0x23, 0x00 }, 3, 0, 3 );</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     uint64_t value;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     ccnxCodecTlvUtilities_GetVarInt(buffer, 3, &amp;value);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     // value = 0x0000000000102300</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9b50b6610ca2593dce8d0b0c1fbeb57c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ccnxCodecTlvUtilities_NestedEncode </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvEncoder *&#160;</td>
          <td class="paramname"><em>outerEncoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nestedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t(*)(CCNxCodecTlvEncoder *innerEncoder, CCNxTlvDictionary *packetDictionary)&#160;</td>
          <td class="paramname"><em>nestedEncoderFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes a nested TLV container (the opposite of ccnxCodecTlvUtilities_DecodeSubcontainer) </p>
<p>Appends a TLV header (4 bytes) to the encoder using 'nestedType' as the TLV type. It then calls 'nestedEncoderFunction' to encode the 'value' of the container. If 'nestedEncoderFunction' returns positive bytes it will go back and fill in the proper TLV length. If 'nestedEncoderFunction' returns 0 or negative bytes, it rewinds the encoder to the original position before appending the TLV header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outerEncoder</td><td>The encoder to append to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>The dictionary to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nestedType</td><td>the TLV type to use for the nested value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nestedEncoderFunction</td><td>The function to call to write the inner value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-negative The total number of bytes appended to 'outerEncoder' </dd>
<dd>
-1 An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   // If the dictionary contains a KeyName Name, then encode the KeyName continer using &#39;rtaTlvSchemaV0KeyName_Encode&#39;.  Use</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   // the value &#39;CCNxCodecSchemaV0_KeyLocatorKeys_KeyName&#39; as the TLV type for the subcontainer.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   //</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   if (ccnxTlvDictionary_IsValueBuffer(packetDictionary, CCNxCodecSchemaV0TlvDictionary_ContentObjectFastArray_KEYNAME_NAME)) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      keynameLength = ccnxCodecTlvUtilities_NestedEncode(keyLocatorEncoder, packetDictionary, CCNxCodecSchemaV0_KeyLocatorKeys_KeyName, rtaTlvSchemaV0KeyName_Encode);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a44aa106085c028d45bc1b11ab3576528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_PutAsBuffer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dictionaryKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes 'length' bytes from the decoder and puts it in the dictionary. </p>
<p>Reads the next 'length' bytes from the decoder and wraps it in a PARCBuffer. The buffer is saved in the packetDictionary under the key 'arrayKey'.</p>
<p>It is an error if there are not 'length' bytes remaining in the decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The input to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>The output dictionary to save the buffer in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The TLV key of the value being read (NOT USED) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The byte length to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionaryKey</td><td>The key to use in the packetDictionary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true 'length' bytes were read and saved in the packetDictionary </dd>
<dd>
false An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   // A list of 2 TLV containers (types 0x000C and 0x000D)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   uint8_t metadataContainer[] = {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      0x00, 0x0C, 0x00, 0x01,     // Object Type, length = 1</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      0x04,                       // LINK</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      0x00, 0x0D, 0x00,    8,     // Creation Time</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      0x00, 0x00, 0x01, 0x43,     // 1,388,534,400,000 msec</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      0x4B, 0x19, 0x84, 0x00,</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   };</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   PARCBuffer *buffer = parcBuffer_Wrap(metadataContainer, sizeof(metadataContainer), 0, sizeof(metadataContainer) );</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   // now decode that snippit</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   CCNxTlvDictionary *dictionary = ccnxTlvDictionary_Create(10,10);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   uint16_t tlvtype = ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   uint16_t tlvlength = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   // The buffer will contain the one byte 0x04.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;   bool success = ccnxCodecTlvUtilities_PutAsBuffer(decoder, dictionary, tlvtype, tlvlength, CCNxCodecSchemaV0TlvDictionary_ContentObjectFastArray_OBJ_TYPE);</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   ccnxTlvDictionary_Release(&amp;dictionary);</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   ccnxCodecTlvDecoder_Destroy(&amp;decoder);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;   assertTrue(success, &quot;There was an unknown TLV at position %zu&quot;, ccnxCodecTlvDecoder_Position(decoder));</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a83ee27e1b65335edf431788274142de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_PutAsHash </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dictionaryKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes a <code>PARCCryptoHash</code> value of 'length' bytes from the decoder and puts it in the dictionary. </p>
<p>It is an error if there are not 'length' bytes remaining in the decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The input to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>The output dictionary to save the buffer in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The TLV key of the value being read (NOT USED) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The byte length to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionaryKey</td><td>The key to use in the packetDictionary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true 'length' bytes were read and saved in the packetDictionary </dd>
<dd>
false An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   // A list of 2 TLV containers (types 0x000C and 0x000D)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   uint8_t hashContainer[] = {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      0x00, 0x01, 0x00, 0x20,     // SHA256 hash, length = 0x20</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   };</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   PARCBuffer *buffer = parcBuffer_Wrap(hashContainer, sizeof(hashContainer), 0, sizeof(hashContainer) );</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   // now decode that snippit</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   CCNxTlvDictionary *dictionary = ccnxTlvDictionary_Create(10,10);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   uint16_t tlvtype = ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   uint16_t tlvlength = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   bool success = ccnxCodecTlvUtilities_PutAsHash(decoder, dictionary, tlvtype, tlvlength, CCNxCodecSchemaV1TlvDictionary_MessageFastArray_OBJHASH_RESTRICTION);</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   ccnxTlvDictionary_Release(&amp;dictionary);</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   ccnxCodecTlvDecoder_Destroy(&amp;decoder);</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a520ee43a507b2b55a6db6de133c79ef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_PutAsInteger </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dictionaryKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the value as a VarInt and saves it as an Integer in the Dictionary. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in</td><td>out in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;#example#&gt;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab7fed3b6b2e00618c67af3fc5f494716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_PutAsListBuffer </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>listKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 'length' bytes from the decoder and appends a PARCBuffer to a list in packetDictionary. </p>
<p>Saves a buffer as part of a List in the packet dictionary. This is primarily used for unknown TLV types that do not have a specific decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>The dictionary to append the buffer in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The TLV type of the buffer (saved as part of the list entry) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length to wrap in the buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listKey</td><td>The list key in packetDictionary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Success </dd>
<dd>
false Failure or error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // If we exhaust all the known keys in the Name Authenticator, the default case will save the TLV in</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  // the container&#39;s list in the packet dictionary.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  //</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  static bool</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  rtaTlvSchemaV0NameAuth_DecodeType(CCNxCodecTlvDecoder *decoder, CCNxTlvDictionary *packetDictionary, uint16_t type, uint16_t length)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     bool success = false;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     switch (type) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;     case CCNxCodecSchemaV0_NameAuthKeys_KeyLocator:</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        success = ccnxCodecTlvUtilities_DecodeSubcontainer(decoder, packetDictionary, type, length, rtaTlvSchemaV0KeyLocator_Decode);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        break;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;     case CCNxCodecSchemaV0_NameAuthKeys_CryptoSuite:</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        success = ccnxCodecTlvUtilities_PutAsBuffer(decoder, packetDictionary, type, length, CCNxCodecSchemaV0TlvDictionary_ContentObjectFastArray_CRYPTO_SUITE);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        break;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;     case CCNxCodecSchemaV0_NameAuthKeys_KeyId:</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        success = ccnxCodecTlvUtilities_PutAsBuffer(decoder, packetDictionary, type, length, CCNxCodecSchemaV0TlvDictionary_ContentObjectFastArray_KEYID);</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        break;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;     default:</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        // if we do not know the TLV type, put it in this container&#39;s unknown list</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        success = ccnxCodecTlvUtilities_PutAsListBuffer(decoder, packetDictionary, type, length, CCNxCodecSchemaV0TlvDictionary_ContentObjectLists_NAMEAUTH_LIST);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        break;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;     }</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;     return success;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7ad8d01fcaa2d12809aa1efe9e80ca45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccnxCodecTlvUtilities_PutAsName </td>
          <td>(</td>
          <td class="paramtype">CCNxCodecTlvDecoder *&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CCNxTlvDictionary *&#160;</td>
          <td class="paramname"><em>packetDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes 'length' bytes from the decoder and puts it in the dictionary as a CCNxName. </p>
<p>Reads the next 'length' bytes from the decoder and wraps it in a CCNxName. The name is saved in the packetDictionary under the key 'arrayKey'.</p>
<p>It is an error if there are not 'length' bytes remaining in the decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The input to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDictionary</td><td>The output dictionary to save the name in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The TLV key of the value being read (NOT USED) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The byte length to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionaryKey</td><td>The key to use in the packetDictionary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true 'length' bytes were read and saved in the packetDictionary </dd>
<dd>
false An error</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   // A list of 2 TLV containers (types 0x000C and 0x000D)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   uint8_t metadataContainer[] = {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      0x00, 0x00, 0x00,    9,     // type = name, length = 9</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      0x00, 0x02, 0x00,    5,     // type = binary, length = 5</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      &#39;h&#39;,  &#39;e&#39;,  &#39;l&#39;,  &#39;l&#39;,      // &quot;hello&quot;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      &#39;o&#39;,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   };</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   PARCBuffer *buffer = parcBuffer_Wrap(metadataContainer, sizeof(metadataContainer), 0, sizeof(metadataContainer) );</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   // now decode that snippit</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(buffer);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   CCNxTlvDictionary *dictionary = ccnxTlvDictionary_Create(10,10);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   uint16_t tlvtype = ccnxCodecTlvDecoder_GetType(decoder);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   uint16_t tlvlength = ccnxCodecTlvDecoder_GetLength(decoder);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   // Saves &quot;lci:/hello&quot;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   bool success = ccnxCodecTlvUtilities_PutAsName(decoder, dictionary, tlvtype, tlvlength, CCNxCodecSchemaV0TlvDictionary_ContentObjectFastArray_NAME);</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   ccnxTlvDictionary_Release(&amp;dictionary);</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   ccnxCodecTlvDecoder_Destroy(&amp;decoder);</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   assertTrue(success, &quot;The Name failed to decode or some other error&quot;);</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright  2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Mon Aug 29 2016 12:44:52
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084575; 
var sc_invisible=0;
var sc_security="bed914f8"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" src="http://c.statcounter.com/11084575/0/bed914f8/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
